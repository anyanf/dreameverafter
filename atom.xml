<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[DreamEverAfter]]></title>
  <link href="www.dreameverafter.com/atom.xml" rel="self"/>
  <link href="www.dreameverafter.com/"/>
  <updated>2023-12-26T18:15:28+08:00</updated>
  <id>www.dreameverafter.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[iOS：特殊符号大全]]></title>
    <link href="www.dreameverafter.com/17032096290541.html"/>
    <updated>2023-12-22T09:47:09+08:00</updated>
    <id>www.dreameverafter.com/17032096290541.html</id>
    <content type="html"><![CDATA[
<p>特殊符号大全分享给大家，直接复制粘贴就可以使用了！</p>
<span id="more"></span><!-- more -->
<pre><code class="language-plain_text">░ ▒ ▬ ◊ ◦ ▣ ۰•● ●•۰ ► ◄ ▧ ▨ ◐ ◑ ↔ ↕ ▪ ▫ ⊙◎ ▧▨◐◑↔↕▪ ▒ ◊◦▣▤▥ ▦▩◘ ◈◇の→あぃ￡Ю〓§▶¤๑⊹⊱⋛⋌⋚⊰⊹ ≈ ๑۩۩.. ..۩۩๑ ๑۩۞۩๑ ~.~ ◕‿-｡ 【】┱ ┲ ღღღ ▶ ▷ ◀ ◁ ⊙ ⓛⓞⓥⓔ ╬ 『 』∴ .｡◕‿◕｡ ∷ ﹌ の ◎ ▶ ► ◄ ▧ ▨ ◐ ◑ ↔ ↕↘ ▀ ▄ █ ▌░ ▒ ▬ ◊ ▐ ░ ▒▬ ◊ ◦ の → ぃ ￡ ｡◕‿◕｡ ஐ.1　⊙●○①⊕◎Θ⊙¤㊣◆◇◣◢◥▲▼△▽⊿◤ ◥　.2　▆ ▇ █ █ ■ ▓ 回 □ 〓≡ ╝╚╔ ╗╬ ═ ╓ ╩ ┠ ┨┯ ┷┏.3　┓┗ ┛┳⊥『』┌ ┐└ ┘∟「」↑↓→←↘↙┇┅ ﹉﹊﹍﹎╭.4　╮╰ ╯ *^_^* ^*^ ^-^ ^_^ ^（^ ∵∴‖｜ ｜︴﹏﹋﹌（）〔〕.5　【】〖〗＠：！/ &quot; _ &lt; &gt; `,·。≈{}~ ～() _ -『』√ $ @ * &amp; # ※.6　卐 々∞Ψ ∪∩∈∏ の ℡ ぁ §∮”〃ミ灬ξ№∑⌒ξζω＊ ㄨ ≮≯ ＋.7　－×÷＋－±／＝∫∮∝ ∞ ∧∨ ∑ ∏ ‖∠ ≌ ∽ ≤ ≥ ≈＜＞じ.8　veve↑↓⊙●■『』◆◣◥▲Ψ ※◤ ◥ →№←㊣∑⌒〖〗＠.9　ξζω□∮〓※∴ぷ▂▃▅▆█ ∏卐【】△√ ∩¤々∞①ㄨ≡↘↙▂.10　▂ ▃ ▄ ▅ ▆ ▇ █┗┛╰╮ ≠ ▂ ▃ ▄ ▅.11．·°∴ ．．·°Yesterday ．·°.12　KicaZ宝贝o(╥﹏╥)o 　じve【 오빠 사랑해요 】*° ^_^........13　┢┦aΡｐy ^_^　　　　ぜ长ヤ乷　｡◕‿◕｡Cool Friends｡◕‿◕｡.14　【】—一　▄【┻┳═一　▄【┳一　▄【┻═┳一　▄【┳-一.15　▄【┻═┳　【┳═一　▄【┳一·　▄【┳═一　【┳═一oO.16　-—═┳【　∝╬══→　::======&gt;&gt;　┈━═　┣▇▇▇═—.17 Chris' Blog™ ๑•ิ.•ั๑ .18 ⊙ ◎ ► ◄ ▧ ▨ ◐ ◑ ↔ ↕ ▪ ▫.19 ▀ ▄ █ ▌ ▐ ░ ▒ ▬ ◊ ◦ ▣ ▤ ▥.20 ▦ ▩ ◘ ◙ ◈ の → あ ぃ ￡ ｡◕‿◕｡.21 ゃōゃ ⊙▂⊙　⊙０⊙　⊙＾⊙　⊙ω⊙　⊙﹏⊙　⊙△⊙　⊙▽⊙.22 ◑▂◐　◑０◐　◑＾◐　◑ω◐　◑﹏◐　◑△◐　　◑▽◐.23 ∩▂∩　∩０∩　∩＾∩　∩ω∩　∩﹏∩　∩△∩　∩▽∩.24 ●▂●　　●０●　　●＾●　　●ω●　　●﹏●　　●△● 　●▽●.25 ∪▂∪　∪０∪　∪＾∪　∪ω∪　∪﹏∪　∪△∪　∪▽∪. 26 ≥▂≤　≥０≤　≥＾≤　≥ω≤　≥﹏≤　≥△≤　≥▽≤. 27 ЙКЛФУЦЧШЩЪЫЭЮЯабвгджзийклфцчшщъыюяё--―‖‥…‰′″※℃℅℉№

웃유▲÷↑↓◆◇⊙■□△▽¿─│Ⓐ▼⌘≈←→◈◎⊿※¡━┃ღツ©®™Σ卐√↖↗●◐Θ◤◥︻〖〗┄┆℃℉°ϟ¢€£∞½×↙↘○◑⊕◣◢︼【】┅┇〓▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕の·▸◂▴▾┈┊①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ㍿▓┉┋تヅツッシÜϡﭢ™℠℗©®۵웃유ღ⊙℃℉ϟ√ㄨ⋆†。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑·¨….¸;！´？！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+=&lt;＿_-\ˇ~﹉﹊（）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】︵︷︿︹︽_﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼†‡◉○◌◍◎●◐◑◒◓◔◕◖◗⊗⊙◘◙◍⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯㊰㊙㉿囍ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ°øⒶ卐⏎←↑→↓↔↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃▀▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥▦▧▨▩▪▫▬▭▮▯㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘

// 特殊符号
◐◑№↑↓←→√×÷℃℉°◆◇⊙■□△▽¿½㍿卍卐〓㎡㊚㊛囍㊒㊖Φ‖@*&amp;#※卍卐Ψ⌒¶∮‖€￡¥
编号序号①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵

// 数学符号
﹢﹣×÷±/=≌∽≦≧≒﹤﹥≈≡≠=≤≥&lt;&gt;≮≯∷∶∫∮∝∞∧∨∑∏∪∩∈∵∴⊥∥∠⌒⊙√∟⊿㏒㏑%‰⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱ 

// 爱心符号
ღ

// 标点符号大全
。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑·¨….¸;！´？！～—ˉ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#﹩$﹠&amp;﹪%*﹡﹢﹦﹤‐￣¯―﹨ˆ˜﹍﹎+=&lt;＿_-\ˇ~﹉﹊（）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】︵︷︿︹︽_﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼

// 单位符号
°′″＄￥〒￠￡％＠℃℉﹩﹪‰﹫㎡㏕㎜㎝㎞㏎m³㎎㎏㏄º○¤%$º¹²³

// 货币符号
€£Ұ₴$₰¢₤¥₳₲₪₵元₣₱฿¤₡₮₭₩ރ円₢₥₫₦zł﷼₠₧₯₨Kčर₹ƒ₸￠

// 箭头符号↑↓←→↖↗↘↙↔↕▶►▷◁◀◄«»⏎↚↛↜↝↞↟↠↠↡↢↣↤↤↥↦↧↨⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇖⇗⇘⇙⇜↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↼↽↾↿⇀⇁⇂⇃⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪↺↻⇚⇛

// 符号图案大全
√ㄨ囍㍿웃유卍卐√×■◆●○◐◑⊙◎▧▨◐◑↔↕▪▒◊◦▣▤▥▦▩◘◈◇の→あぃ￡Ю〓§▶¤【】┱┲ღ▶▷◀◁⊙ⓛⓞⓥⓔ╬『』∴∷﹌の◎▶►◄▧▨◐◑↔↕↘▀▄█▌◦の→ぃ￡▒▬◊◦▣۰••۰►◄▧▨◐◑↔↕▪▫⊙●○①⊕◎Θ⊙¤㊣◆◇◣◢◥▲▼△▽⊿◤◥⊙◎►◄▧▨◐◑↔↕▪▫▀▄█▌▐░▒▬◊◘◙◦▣▤▥▦▩◘◙◈ºº₪¤큐«»™　◕‿-｡　｡◕‿◕｡

// 希腊字母
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζνξοπρσηθικλμτυφχψω

//俄语字母
АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя

// 汉语拼音
āáǎàōóǒòēéěèīíǐìūúǔùǖǘǚǜüêɑńňɡㄅㄆㄇㄈㄉㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ

// 中文字符
零壹贰叁肆伍陆柒捌玖拾佰仟万亿吉太拍艾分厘毫微卍卐卄巜弍弎弐朤氺曱甴囍兀々〆のぁ〡〢〣〤〥〦〧〨〩㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉

// 日文字符大全
ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをんゔゕゖァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴヵヶヷヸヹヺ・ーヽヾヿ

 

// 制表符
─ ━│┃╌╍╎╏┄ ┅┆┇┈ ┉┊┋┌┍┎┏┐┑┒┓└ ┕┖┗ ┘┙┚┛├┝┞┟┠┡┢┣ ┤┥┦┧┨┩┪┫┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳ ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻┼ ┽ ┾ ┿ ╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╪ ╫ ╬═║╒╓╔ ╕╖╗╘╙╚ ╛╜╝╞╟╠ ╡╢╣╤ ╥ ╦ ╧ ╨ ╩ ╳╔ ╗╝╚ ╬ ═ ╓ ╩ ┠ ┨┯ ┷┏ ┓┗ ┛┳ ⊥ ﹃ ﹄┌ ╮ ╭ ╯╰
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[三汁焖锅]]></title>
    <link href="www.dreameverafter.com/16996865532784.html"/>
    <updated>2023-11-11T15:09:13+08:00</updated>
    <id>www.dreameverafter.com/16996865532784.html</id>
    <content type="html"><![CDATA[
<p>👉食材：鸡翅、鸡爪、虾、鹌鹑蛋、玉米、土豆…（你喜欢的食材都可以放）<br />
👉秘制料汁：2勺料酒+4勺生抽+2勺老抽+2勺蚝油+1勺豆瓣酱+1勺甜面酱+4勺番茄酱+1勺胡椒粉+1勺辣椒面（这个料汁，焖啥都好吃！！）</p>
<span id="more"></span><!-- more -->
<p>👉步骤：<br />
1、素菜切块，虾用料酒+姜片腌制；鸡翅划几刀，和鸡爪一起用料酒+姜片+1勺生抽，腌制15分钟左右去腥<br />
2、煮锅中倒少许油，底下铺上各种素菜，上层铺上肉，倒上料汁，180度焖35分钟左右，出锅放点青红椒和芝麻点缀就可以了</p>
<p>👉配着三汁焖锅再打一个解腻的的果汁：橙子+雪梨+500ml水！这配方清爽又好喝解腻！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[别了，中国大陆的Kindle]]></title>
    <link href="www.dreameverafter.com/17001172774052.html"/>
    <updated>2023-11-16T14:47:57+08:00</updated>
    <id>www.dreameverafter.com/17001172774052.html</id>
    <content type="html"><![CDATA[
<p>这几年 Amazon 一步步退出中国市场，似乎预示着这一天已经不远。果不其然，前阵子 Amazon 官方宣布退出中国电子书业务。今年五月由于疫情在家远程办公一周，苦于 Kindle 放公司忘了带回家无 Kindle 可看，遂准备买个新的 Whitepaper5。找一圈发现，Whitepaper5 在官方渠道没有销售，当时就感觉不太对劲。如今，算是正式开启退出中国市场的计划了。</p>
<span id="more"></span><!-- more -->
<p>我也算是 Kindle 比较早期的用户了，从一开始的标准版，到 Oasis2，到现在的 Whitepaper5，一共使用过 3 个设备。还给媳妇买了个 Kindle，不过她一直没有用这个看书的习惯，基本上属于吃灰的状态。</p>
<p>在 Kindle 中国商城里买了不少电子书，甚至大部分都没看过，毕竟买过就算是看过了哈哈。退出这个事情正好也刺激了我看书的进度，这段时间把看 Kindle 的优先级调高了很多，有点时间就拿起来看看。</p>
<p>其实八月是有一个好消息的，那就是 Kindle 支持 epub 的格式转换了，今年我一度因为各种格式的割裂，想做一个全格式支持的本地阅读器应用，由于疫情原因，无限期搁置了。当知道这个消息后，感觉这个阅读器应用的意义不大了。</p>
<p>对于一直漂来漂去的我来说，可以随时随地买到或找到想看的书，着实比实体书香很多，不占地方，而且搬家也减轻了不少负担。每次搬家，搬家师傅都问我有没有书，被问的我都有点尴尬。有，也不少，两箱。这已经是尽量找电子书的前提了，没办法，很多书要不没有电子版，要不就是不适合小屏幕阅读。</p>
<p>还好它只是退出中国市场，美服账号还可以继续使用，正好很多英文书在国内不是很方便的购买。不过中国书电子书在往后的一段时间内，质量和数量应该会有些退步了。</p>
<p>这件事也充分体现出来购买电子化产品的优缺点，以后买电子产品，要认真思考一下要的是什么，是否符合预期，实效性等问题了。</p>
<p>他来了，掀起一波电子书正版化的潮流，也开发出盖泡面新姿势，现在他走了，应该不会再见了。</p>
<p>别了，中国大陆的Kindle。</p>
<p><img src="media/17001172774052/kindle.jpg" alt="kindle" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HomeBrew更新报错“fatal- Could not resolve HEAD to a revision”]]></title>
    <link href="www.dreameverafter.com/17001265068678.html"/>
    <updated>2023-11-16T17:21:46+08:00</updated>
    <id>www.dreameverafter.com/17001265068678.html</id>
    <content type="html"><![CDATA[
<p>今天想通过 <code>brew</code> 装 <code>openvc</code>，结果发现根本 <code>search</code> 不到。<br />
但是网上搜索怎么安装这个库，的确都是用 <code>brew</code>，所以想更新一下 <code>brew</code> 再搜。</p>
<span id="more"></span><!-- more -->
<p>结果更新直接报错如下：</p>
<pre><code class="language-plain_text">brew update

fatal: Could not resolve HEAD to a revision

Already up-to-date.
</code></pre>
<p>看似 <code>Already up-to-date.</code>，实际上什么都没更新下来。<br />
解决方法如下：</p>
<h3><a id="1%E6%89%BE%E5%88%B0%E6%9B%B4%E6%96%B0%E6%97%B6%E5%80%99%E5%87%BA%E9%94%99%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 找到更新时候出错的路径。</h3>
<pre><code class="language-plain_text">brew update --verbose

Checking if we need to fetch /usr/local/Homebrew...

Checking if we need to fetch /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask...

Checking if we need to fetch /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core...

Fetching /usr/local/Homebrew...

Updating /usr/local/Homebrew...

Branch 'master' set up to track remote branch 'master' from 'origin'.

Switched to and reset branch 'master'

Your branch is up to date with 'origin/master'.

Switched to and reset branch 'stable'

Current branch stable is up to date.

Updating /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core...

fatal: Could not resolve HEAD to a revision

Already up-to-date.
</code></pre>
<p>不难看出出错的路径是 <code>/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</code></p>
<h3><a id="2%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%87%BA%E9%94%99%E8%B7%AF%E5%BE%84%E4%BB%93%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 手动更新出错路径仓库</h3>
<pre><code class="language-plain_text">cd /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core

git fetch --prune origin

git pull --rebase origin master

From https://github.com/Homebrew/homebrew-core

* branch                    master     -&gt; FETCH_HEAD
</code></pre>
<p><code>pull</code> 成功后，就已经更新完成，不放心的可以再执行一下 <code>brew update</code> 看还有没有报错。<br />
更新完后，自然可以正常安装 <code>opencv</code> 了。</p>
<h3><a id="ps%EF%BC%9A%E5%BB%BA%E8%AE%AE%E6%9B%B4%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%EF%BC%8C%E6%9C%89%E5%BC%BA%E8%BF%AB%E7%97%87%E7%9A%84%E5%8F%AF%E4%BB%A5%E4%B8%B4%E6%97%B6%E6%9B%B4%E6%8D%A2%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PS： 建议更换国内源，有强迫症的可以临时更换。</h3>
<pre><code class="language-plain_text"># 临时替换：
export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.ustc.edu.cn/homebrew-bottles&quot;

# 永久替换
# 对于 bash 用户
echo 'export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.ustc.edu.cn/homebrew-bottles&quot;' &gt;&gt; ~/.bash_profile

# 对于 zsh 用户
echo 'export HOMEBREW_BOTTLE_DOMAIN=&quot;https://mirrors.ustc.edu.cn/homebrew-bottles&quot;' &gt;&gt; ~/.zshrc
</code></pre>
<p>参考：</p>
<ol>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/</a></li>
<li><a href="https://mirrors.ustc.edu.cn/help/homebrew-bottles.html">https://mirrors.ustc.edu.cn/help/homebrew-bottles.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SwiftUI基本控件]]></title>
    <link href="www.dreameverafter.com/17001892553950.html"/>
    <updated>2023-11-17T10:47:35+08:00</updated>
    <id>www.dreameverafter.com/17001892553950.html</id>
    <content type="html"><![CDATA[
<p>准备用SwiftUI撸个小项目玩一下，边做边记录用到的东西。</p>
<span id="more"></span><!-- more -->
<h2><a id="text" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Text</h2>
<pre><code class="language-swift">Text(&quot;文字&quot;)
    .font(.custom(&quot;BradleyHandITCTT-Bold&quot;, size: 36))
    .frame(width: 200, height: 80, alignment: .bottomTrailing)
</code></pre>
<h2><a id="textfield" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TextField</h2>
<pre><code class="language-swift">TextField(&quot;User Name&quot;, text: $username, onEditingChanged: { (value) in
	    print(&quot;onEditingChanged:\(self.username)&quot;)
	}) {
	    print(&quot;onCommit:\(self.username)&quot;)
	}.textFieldStyle(RoundedBorderTextFieldStyle())
	//密码输入框
    Text(&quot;Your password is \(password)!&quot;)
    
    SecureField(&quot;Your password&quot;, text: $password) {
        print(&quot;Your password is \(self.password)!&quot;)
    }
    .textFieldStyle(RoundedBorderTextFieldStyle())
</code></pre>
<h2><a id="button" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Button</h2>
<pre><code class="language-swift">Button(action: {
	print(&quot;---Third button action.&quot;)
    }) {
	Image(systemName: &quot;clock&quot;)
	Text(&quot;Third button&quot;)
    }
    .foregroundColor(Color.white)
    .background(Color.orange)
    
 Button(action: {
	print(&quot;---Button with image.&quot;)
    }){
	HStack {
	    Image(systemName: &quot;star&quot;)
	    Text(&quot;Button with image&quot;)
	}
	.padding()
	    .background(Color.yellow)
    }
</code></pre>
<h2><a id="spacer%E6%98%AF%E4%B8%80%E4%B8%AA%E7%81%B5%E6%B4%BB%E7%9A%84%E7%A9%BA%E9%97%B4%E8%A7%86%E5%9B%BE%EF%BC%8C%E5%9C%A8%E4%B8%A4%E4%B8%AAx%E6%88%96y%E8%BD%B4%E4%B8%8A%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Spacer是一个灵活的空间视图，在两个x或y轴上进行扩展</h2>
<pre><code class="language-swift">HStack {
     Image(systemName: &quot;clock&quot;)
     Spacer(minLength: 50)
     Text(&quot;\(Date())&quot;)
}
</code></pre>
<h2><a id="divider" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Divider</h2>
<p>分割线，和容器方向垂直。</p>
<pre><code class="language-swift"> Image(systemName: &quot;clock&quot;)
 Divider()
    .background(Color.purple)
    .scaleEffect(CGSize(width: 1, height: 10))
 Text(&quot;\(Date())&quot;)
</code></pre>
<h2><a id="image" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Image</h2>
<pre><code class="language-swift">Image(&quot;imageName&quot;)
	.resizable()
	.aspectRatio(contentMode: .fit)
Image(&quot;imageName&quot;)
	.blur(radius: CGFloat(2), opaque: true)
Image(&quot;imageName&quot;)
        .mask(Circle())
Image(&quot;texture&quot;)
        .resizable()
        .frame(width: 300, height: 300)
        .mask(
Text(&quot;SWIFT UI!&quot;)
	.font(Font.system(size: 64).bold()))
Image(&quot;girlPicture&quot;)
	.scaleEffect(0.8)
</code></pre>
<h2><a id="picker%E7%9B%B8%E5%BD%93%E4%BA%8Euikit%E4%B8%AD%E7%9A%84uipickerview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Picker相当于UIKit中的UIPickerView</h2>
<pre><code class="language-swift"> struct ContentView : View {

 var number = [&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]
 @State private var selectedItem = 0

 var body: some View {
    VStack {
        
       Picker(selection: $selectedItem, label: Text(&quot;Number&quot;)) {
          ForEach(0 ..&lt; number.count) {
            Text(self.number[$0]).tag($0).foregroundColor(self.colors[$0])
          }
       }
       Text(&quot;Your choice: &quot;)
        + Text(&quot;\(number[selectedItem])&quot;).foregroundColor(self.colors[selectedItem])
    }
 }
}
</code></pre>
<h2><a id="pickerdate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PickerDate</h2>
<pre><code class="language-swift"> DatePicker(selection: $selectedDate, displayedComponents: DatePickerComponents.date) {
        Text(&quot;Date&quot;)
    }
</code></pre>
<h2><a id="slider" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Slider</h2>
<pre><code class="language-swift">   Slider(value: $temperature, in: -20...40) { (item) in
        print(item)
    }
</code></pre>
<h2><a id="stepper" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stepper</h2>
<pre><code class="language-swift">    Stepper(onIncrement: {
        self.temperature += 1
    }, onDecrement: {
        self.temperature -= 1
    }, label: { Text(&quot;Temperature: \(Int(temperature))&quot;) })

</code></pre>
<h2><a id="segment%E4%BC%BC%E4%BA%8Euikit%E4%B8%AD%E7%9A%84uisegmentedcontrol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Segment似于UIKit中的UISegmentedControl</h2>
<pre><code class="language-swift">Picker(selection: $selectedAnimal, label: Text(&quot;animals&quot;)) {
       ForEach(0 ..&lt; animals.count) {
        Text(self.animals[$0]).tag($0)
       }
    }.pickerStyle(SegmentedPickerStyle())

</code></pre>
<h2><a id="toggle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Toggle</h2>
<pre><code class="language-swift">Toggle(isOn: $showNotification) {
        Text(&quot;Show notification:&quot;)
    }.padding()
</code></pre>
<h2><a id="tabview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TabView</h2>
<pre><code class="language-swift">TabView {
    Text(&quot;The home page.&quot;)
	.font(.system(size: 21))
	.tabItem({
	    Image(systemName: &quot;imageName&quot;)
	    Text(&quot;Home&quot;) })
	.tag(0)

    Text(&quot;The settings page&quot;)
	.font(.system(size: 21))
	.tabItem({
	    Image(systemName: &quot;gear&quot;)
	    Text(&quot;Settings&quot;)
	})
	.tag(1)
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LiSSA第四代计时器说明书]]></title>
    <link href="www.dreameverafter.com/17001171363865.html"/>
    <updated>2023-11-16T14:45:36+08:00</updated>
    <id>www.dreameverafter.com/17001171363865.html</id>
    <content type="html"><![CDATA[
<p><img src="media/17001171363865/LiSSA-header.jpeg" alt="LiSSA-header" /></p>
<p>之前买了一个LISSA的计时器作为时间管理的工具，发现该计时器是目前我看到最能满足我需求的。如下几个功能是我需要的。</p>
<span id="more"></span><!-- more -->
<ol>
<li>倒计时</li>
<li>正计时</li>
<li>闹钟</li>
<li>番茄工作及时</li>
<li>支持蜂鸣提醒，两级音量可调。</li>
<li>支持振动提醒（这个功能非常有用，尤其是在安静的办公室或者图书馆，支持振动的计时器不多，我也是花功夫找了一阵子才找到）。</li>
</ol>
<p>以上文字是我借鉴的，等有时间了自己梳理一下，重点是说明书。</p>
<p><img src="media/17001171363865/desc1.jpg" alt="desc1" /><br />
<img src="media/17001171363865/desc2.jpg" alt="desc2" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码大全——1.欢迎进入软件构建的世界]]></title>
    <link href="www.dreameverafter.com/17001195727549.html"/>
    <updated>2023-11-16T15:26:12+08:00</updated>
    <id>www.dreameverafter.com/17001195727549.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<p>以下是阅读代码大全摘抄。</p>
<ol>
<li>软件构建是软件开发的核心活动；构建活动是每个项目中唯一一项必不可少的工作。</li>
<li>软件构建的主要活动包括：详细设计、编码、调试、集成、开发者测试（develope texting）（包括单元测试和集成测试）。</li>
<li>构建也常被称作“编码”和“编程”。</li>
<li>构建活动的质量对软件的质量有着实质性的影响。</li>
<li>最后，你对“如何进行构建”的理解程度，决定了你这名程序员的优秀程度——这就是本书其余部分的主题了。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ STL简介]]></title>
    <link href="www.dreameverafter.com/17001191890787.html"/>
    <updated>2023-11-16T15:19:49+08:00</updated>
    <id>www.dreameverafter.com/17001191890787.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<pre><code class="language-cpp">vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序
</code></pre>
<pre><code class="language-cpp">pair&lt;int, int&gt;
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
</code></pre>
<pre><code class="language-cpp">string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址
</code></pre>
<pre><code class="language-cpp">queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;
</code></pre>
<pre><code class="language-cpp">stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []
</code></pre>
<pre><code class="language-cpp">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()
</code></pre>
<pre><code class="language-cpp">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--
</code></pre>
<pre><code class="language-cpp">bitset, 圧位
    bitset&lt;10000&gt; s;
    ~, &amp;, |, ^
    &gt;&gt;, &lt;&lt;
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用代码模板2——数据结构]]></title>
    <link href="www.dreameverafter.com/17001178696932.html"/>
    <updated>2023-11-16T14:57:49+08:00</updated>
    <id>www.dreameverafter.com/17001178696932.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h3><a id="%E5%8D%95%E9%93%BE%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单链表</h3>
<pre><code class="language-cpp">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
</code></pre>
<h3><a id="%E5%8F%8C%E9%93%BE%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双链表</h3>
<pre><code class="language-cpp">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
</code></pre>
<h3><a id="%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>栈</h3>
<pre><code class="language-cpp">// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt &gt; 0)
{

}
</code></pre>
<h3><a id="%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>队列</h3>
<p>普通队列：</p>
<pre><code class="language-cpp">// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh &lt;= tt)
{

}
</code></pre>
<p>循环队列：</p>
<pre><code class="language-cpp">// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
</code></pre>
<h3><a id="%E5%8D%95%E8%B0%83%E6%A0%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单调栈</h3>
<pre><code class="language-cpp">常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i &lt;= n; i ++ )
{
    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
</code></pre>
<h3><a id="%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单调队列</h3>
<pre><code class="language-cpp">常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i &lt; n; i ++ )
{
    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
</code></pre>
<h3><a id="kmp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>KMP</h3>
<pre><code class="language-cpp">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i &lt;= m; i ++ )
{
    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i &lt;= n; i ++ )
{
    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
</code></pre>
<h3><a id="trie%E6%A0%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Trie树</h3>
<pre><code class="language-cpp">int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
</code></pre>
<h3><a id="%E5%B9%B6%E6%9F%A5%E9%9B%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>并查集</h3>
<pre><code class="language-cpp">(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);

(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i &lt;= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);

(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i &lt;= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
</code></pre>
<h3><a id="%E5%A0%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>堆</h3>
<pre><code class="language-cpp">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;
    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])
    {
        heap_swap(u, u / 2);
        u &gt;&gt;= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
</code></pre>
<h3><a id="%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一般哈希</h3>
<pre><code class="language-cpp">(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null &amp;&amp; h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
</code></pre>
<h3><a id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>字符串哈希</h3>
<pre><code class="language-cpp">核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i &lt;= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用代码模板1——基础算法]]></title>
    <link href="www.dreameverafter.com/17001178251653.html"/>
    <updated>2023-11-16T14:57:05+08:00</updated>
    <id>www.dreameverafter.com/17001178251653.html</id>
    <content type="html"><![CDATA[
<span id="more"></span><!-- more -->
<h3><a id="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速排序算法模板</h3>
<pre><code class="language-cpp">void quick_sort(int q[], int l, int r)
{
    if (l &gt;= r) return;

		int i = l - 1, j = r + 1, x = q[(l + r) &gt;&gt; 1];
    while (i &lt; j)
    {
        do i ++ ; while (q[i] &lt; x);
        do j -- ; while (q[j] &gt; x);
        if (i &lt; j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
</code></pre>
<h3><a id="%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速选择算法模板</h3>
<pre><code class="language-cpp">int quick_select(int q[], int l, int r, int k) {

    if (l &gt;= r) return q[l];
    int i = l - 1, j = r + 1, x = q[(l + r) &gt;&gt; 1];

    while (i &lt; j) {
        while (q[++i] &lt; x);
        while (q[--j] &gt; x);
        if (i &lt; j) swap(q[i],  q[j]);
    }

    if (j - l + 1 &gt;= k) return quick_select(q, l, j, k);
    else return quick_select(q, j + 1, r, k - (j - l + 1));
}
</code></pre>
<h3><a id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>归并排序算法模板</h3>
<pre><code class="language-cpp">const int N = 1e5 + 10; // 数组元素个数

int a[N], tmp[N];

void merge_sort(int q[], int l, int r)
{
    if (l &gt;= r) return;

    int mid = l + r &gt;&gt; 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= r)
        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];
    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
}
</code></pre>
<h3><a id="%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>整数二分算法模板</h3>
<pre><code class="language-cpp">bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre>
<h3><a id="%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>浮点数二分算法模板</h3>
<pre><code class="language-cpp">bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l &gt; eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
</code></pre>
<h3><a id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高精度加法</h3>
<pre><code class="language-cpp">// C = A + B, A &gt;= 0, B &gt;= 0
vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
{
    if (A.size() &lt; B.size()) return add(B, A);

    vector&lt;int&gt; C;
    int t = 0;
    for (int i = 0; i &lt; A.size(); i ++ )
    {
        t += A[i];
        if (i &lt; B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
</code></pre>
<h3><a id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高精度减法</h3>
<pre><code class="language-cpp">bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
{
    if (A.size() != B.size()) return A.size() &gt; B.size();

    for (int i = A.size() - 1; i &gt;= 0; i -- )
        if (A[i] != B[i])
            return A[i] &gt; B[i];

    return true;
}

// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0
vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)
{
    vector&lt;int&gt; C;
    for (int i = 0, t = 0; i &lt; A.size(); i ++ )
    {
        t = A[i] - t;
        if (i &lt; B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t &lt; 0) t = 1;
        else t = 0;
    }

    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
}
</code></pre>
<h3><a id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E4%BD%8E%E7%B2%BE%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高精度乘低精度</h3>
<pre><code class="language-cpp">// C = A * b, A &gt;= 0, b &gt; 0
vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)
{
    vector&lt;int&gt; C;

    int t = 0;
    for (int i = 0; i &lt; A.size() || t; i ++ )
    {
        if (i &lt; A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();

    return C;
}
</code></pre>
<h3><a id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E4%BB%A5%E4%BD%8E%E7%B2%BE%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高精度除以低精度</h3>
<pre><code class="language-cpp">// A / b = C ... r, A &gt;= 0, b &gt; 0
vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)
{
    vector&lt;int&gt; C;
    r = 0;
    for (int i = A.size() - 1; i &gt;= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();
    return C;
}
</code></pre>
<h3><a id="%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一维前缀和</h3>
<pre><code class="language-cpp">S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
</code></pre>
<h3><a id="%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二维前缀和</h3>
<pre><code class="language-cpp">S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
</code></pre>
<h3><a id="%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一维差分</h3>
<pre><code class="language-cpp">给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
</code></pre>
<h3><a id="%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二维差分</h3>
<pre><code class="language-cpp">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
</code></pre>
<h3><a id="%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双指针算法</h3>
<pre><code class="language-cpp">for (int i = 0, j = 0; i &lt; n; i ++ )
{
    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
</code></pre>
<h3><a id="%E7%A6%BB%E6%95%A3%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>离散化</h3>
<pre><code class="language-cpp">vector&lt;int&gt; alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (alls[mid] &gt;= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
</code></pre>
<h3><a id="%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>区间合并</h3>
<pre><code class="language-cpp">// 将所有存在交集的区间合并
void merge(vector&lt;PII&gt; &amp;segs)
{
    vector&lt;PII&gt; res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed &lt; seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 70 爬楼梯(青蛙跳台阶)]]></title>
    <link href="www.dreameverafter.com/17001875302707.html"/>
    <updated>2023-11-17T10:18:50+08:00</updated>
    <id>www.dreameverafter.com/17001875302707.html</id>
    <content type="html"><![CDATA[
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<span id="more"></span><!-- more -->
<p>示例 1：</p>
<pre><code class="language-plain_text">输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
</code></pre>
<p>示例 2：</p>
<pre><code class="language-plain_text">输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
</code></pre>
<h2><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划</h2>
<p>\(f(n)\) 表示爬到第 \(n\) 级台阶的方案数，根据题意，最后一步只有两种可能：跨了一级台阶，或者跨了两级台阶。</p>
<p>所以爬 \(n\) 级台阶的方案总数是爬到第 \(x−1\) 级台阶的方案数和爬到第 \(x−2\) 级台阶的方案数的和。</p>
<p>可以列以下动态规划的转移方程：</p>
<p>\(f(n)=f(n−1)+f(n−2)\)</p>
<p>然后再考虑以下边界条件:</p>
<ol>
<li>从第 0 级爬到第 0 级只有一种方案，\(f(0) = 1\)。</li>
<li>从第 0 级爬到第 1 级只有一种方案，\(f(1) = 1\)。</li>
</ol>
<p>根据这两个边界条件再结合转移方程就可以推导出第 \(n\) 级台阶的方案数。</p>
<p>递归解法就不写了，下面列出for循环解法和降低空间复杂度解法。</p>
<pre><code class="language-c++">
// for循环解法
class Solution {
public:
    int climbStairs(int n) {
        const int N = 1e5 + 10;
    	int dp[N] = {};
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i &lt;= n; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};

// 由于 f(n) 只跟 f(n−1) 和 f(n−2) 有关，所以不需要长度为 n 的数组记录所有的方案数。
// 只需要 p 和 q 两个变量轮着记录就可以了。
class Solution {
public:
    int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 1; i &lt;= n; ++i) {
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
};

</code></pre>
<p>时间复杂度：循环执行 \(n\) 次，每次花费常数的时间代价，故渐进时间复杂度为 \(O(n)\)。</p>
<p>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 \(O(1)\)。</p>
<h2><a id="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%9A%E9%A1%B9%E5%85%AC%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>斐波那契数列通项公式</h2>
<p>经过观察可以看出来方案数很像斐波那契数列，那么就可以直接用通项公式了。</p>
<p>主意斐波那契数列（0、1、1、2、3、5、8、13、21、34、……）和题目方案数列（1、1、2、3、5、8、13、21、34、……）开始的时候不太一样，所以在用主意斐波那契数列通项公式计算的时候， \(n\) 需要加一。</p>
<p>推导过程如下：</p>
<p>根据线性递推数列方程 \(f(n)=f(n−1)+f(n−2)\)，可知道其特征方程为</p>
<p>\(x^2=x+1\)</p>
<p>解得 \(x_1 = {1 + \sqrt{5} \over 2}，x_2 = {1 - \sqrt{5} \over 2}\)</p>
<p>则 \(f(n) = c_1x_1^n+c_2x_2^n\)</p>
<p>因为 \(f(1) = f(2) = 1\)</p>
<p>所以 \(c_1x_1+c_2x_2 = c_1x_1^2+c_2x_2^2 = 1\)</p>
<p>解得 \(c_1 = {1 \over \sqrt{5}}，c_2 = -{1 \over \sqrt{5}}，\)</p>
<p>所以 \(f(n) = {1 \over \sqrt{5}}[({1 + \sqrt{5} \over 2})^n - ({1 - \sqrt{5} \over 2})^n]\)</p>
<p>只要我们把这个公式转换成代码就可以求解了。</p>
<pre><code class="language-c++">class Solution {
public:
    int climbStairs(int n) {
        double sqrt5 = sqrt(5);
        // 主意这里是 n + 1
        double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);
        return (int)round(fibn / sqrt5);
    }
};
</code></pre>
<h2><a id="%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%8D%87%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>爬楼梯升级</h2>
<p>条件改为每次你可以爬 \(1\) 到 \(n\) 个台阶。那么有多少种不同的方法可以爬到楼顶呢？</p>
<p>根据上题目的规律，可以得出下面公式：</p>
<p>\(f(n)=f(0)+f(1)+f(2)+…+f(n-2)+f(n-1)\)</p>
<p>因为 \(f(n-1)=f(0)+f(1)+f(2)+…f(n-2)\)</p>
<p>所以 \(f(n)=2f(n-1)\)</p>
<p>因为 \(f(0) = f(1) = 1\)</p>
<p>所以 \(f(2)=2f(1)=2，f(3)=2f(2)=4，f(4)=2f(3)=8\)</p>
<p>所以 \(f(n)=2^{n-1}\)</p>
<p>其实还有一个更巧妙的思路：一共要上 \(n\) 个台阶，每次都可以爬 \(1\) 到 \(n\) 个台阶，算一共又多少种方法，那么到第 \(n\) 个台阶的时候，把前面 \(n-1\) 个台阶被踩和不被踩的可能性数量统计出来就是答案了，也就是 \(2^{n-1}\)。</p>
<p>代码过于简单，就不列出来了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[终于看完了《扎克·施奈德版正义联盟》]]></title>
    <link href="www.dreameverafter.com/17001155269640.html"/>
    <updated>2023-11-16T14:18:46+08:00</updated>
    <id>www.dreameverafter.com/17001155269640.html</id>
    <content type="html"><![CDATA[
<p>开始我是没想到看一个电影会这么难。</p>
<span id="more"></span><!-- more -->
<p>上个月突然各种群里都在说扎导版的正义联盟，<a href="https://movie.douban.com/subject/35076714/">豆瓣</a>上一查分还很高，然后我也就跟风下了个准备看看，一打开四个小时差点劝退，然后看了一下影评，大概意思是之前两个小时版本根本讲不清楚，所以还是选择看下去。</p>
<p>不过看的过程又遇到了一些阻力，字幕没有双语的，都手动设置一下第二字幕，但是那样两个字幕位置差的就很远，体验很不爽。再加上这个好像得用支持HDR的显示器，才能看出来效果，普通显示器看的话，颜色很淡，正好我那个显示器的HDR很渣，跟没有一样，后来用播放器模拟了一下，颜色凑活能看了。</p>
<p>经过上次种种的阻碍，再看了两个小故事后，暂停了一下，然后就没有然后了。昨天听说国内的视频平台上架了这个电影，今天上午试看感觉不过，字幕是双语的，颜色似乎也正常了（也许是我的眼睛已经适应了这个电影的颜色），所以就斥资六大洋购买了电影，一口气看完了它。</p>
<p>看到中间渐渐发现，我似乎之前跟媳妇在电影院看过那个两小时版的，接着就在豆瓣上查了一下，的确在2017年11月18日看过了，再次给我惊人的遗忘能力跪了，可能当时也就是看了个热闹。扎导版的确故事讲得更清晰一些，而且也够吸引人，不会觉得冗长乏味。打斗镜头也非常精彩，该燃的地方也很燃。别的就不说什么了，肚子里本来就没啥东西，晃荡不出来什么，豆瓣上各种影评也讲了不少。最后提一句，闪电侠才是yyds！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[观《观山海》]]></title>
    <link href="www.dreameverafter.com/17001174083229.html"/>
    <updated>2023-11-16T14:50:08+08:00</updated>
    <id>www.dreameverafter.com/17001174083229.html</id>
    <content type="html"><![CDATA[
<p>久闻《山海经》大名了，却一直没有细致的看过。可能是潜意识觉得看这本书需要精心挑选一个版本，然后斋戒三日沐浴更衣才能开始看吧。这样的想法反而造成的极大的行为成本，结果就是直到今天才有一个看这本书的契机，没错，还是被动的。</p>
<span id="more"></span><!-- more -->
<p>《观山海》是媳妇前两年买的，当时她不知何故文青气质爆炸，然后就买了这本书。本身我是没打算看的，也就不曾研究这版和原版之间的差异，毕竟是媳妇买的，她开心比什么都重要。前两个月面临夏天可能要搬家的事实，意识到家里各种物件实在太多，回想起上次搬家差点要了老命，就起了把家里的东西“精简”一下的念头。扔是不可能扔的，大方向就是不常用甚至就没用过的，直接邮寄回家了事。至于那好几排的书，得提上日程尽快看完，也邮回家。《观山海》自然是尽快看完的首选，谁让它又大又厚呢。</p>
<p>书中的插画是真的棒，之前在别的书里也偶有提到《山海经》中的神怪的地方，但是只能自我发挥想象，每个神怪的样子并不是很清晰，有的只是一个符号。这书里的插画让我心中的那些符号有了具体的形象，画风非常细腻，看着很过瘾。</p>
<p>最让我头大的是，我发现这书，首先是一本地理书，而我是很不擅长记这些的，看过基本上就忘记了，只有一点点方向上的概念，还有特产矿石什么的，完全记不住。里面还会提到一些祭祀的方式，各种怪物吃了有什么功效等等，感觉这就是一本古代的百科全书。听说这版内容不是全的，也无所谓了，反正都记不住，我也就是看个热闹。</p>
<p>这几年看书功利性很强，包括这本也是带着目的去看的（尽快看完），不过看了部分后，就不再惦记这些，被其内容和插画所吸引，看进去了。很久没有体验过这种毫无负担（记不住）看书过程了，有点小感触，就写在这里了。</p>
<p><img src="media/17001174083229/17001174544409.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解计算机系统(第二版) 家庭作业 第二章]]></title>
    <link href="www.dreameverafter.com/17001265070006.html"/>
    <updated>2023-11-16T17:21:46+08:00</updated>
    <id>www.dreameverafter.com/17001265070006.html</id>
    <content type="html"><![CDATA[
<p>正在看《深入理解计算机系统》这本书，课后茫茫多的习题，看着就让人发怵。。</p>
<p>做的时候也需要验证一下对错，所以在网上找了很多相关的题解。顺便就在这里记一下了。</p>
<span id="more"></span><!-- more -->
<p>先放一下源码地址：</p>
<p><a href="http://csapp.cs.cmu.edu/2e/code.html">Code Examples</a></p>
<p>第二章各种编码和绕来套取的计算当时差点把我劝退，做个小结就是一般来说整数用补码编码，浮点数用 IEEE 浮点编码，和小心精度问题。</p>
<h2><a id="2-55" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.55</h2>
<p>先上 show-bytes.c 源码：</p>
<pre><code class="language-c">/* $begin show-bytes */
#include &lt;stdio.h&gt;
/* $end show-bytes */
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
/* $begin show-bytes */

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, int len) {
    int i;
    for (i = 0; i &lt; len; i++)
	printf(&quot; %.2x&quot;, start[i]);    //line:data:show_bytes_printf
    printf(&quot;\n&quot;);
}

void show_int(int x) {
    show_bytes((byte_pointer) &amp;x, sizeof(int)); //line:data:show_bytes_amp1
}

void show_float(float x) {
    show_bytes((byte_pointer) &amp;x, sizeof(float)); //line:data:show_bytes_amp2
}

void show_pointer(void *x) {
    show_bytes((byte_pointer) &amp;x, sizeof(void *)); //line:data:show_bytes_amp3
}
/* $end show-bytes */


/* $begin test-show-bytes */
void test_show_bytes(int val) {
    int ival = val;
    float fval = (float) ival;
    int *pval = &amp;ival;
    show_int(ival);
    show_float(fval);
    show_pointer(pval);
}
/* $end test-show-bytes */

void simple_show_a() {
/* $begin simple-show-a */
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &amp;val;
show_bytes(valp, 1); /* A. */
show_bytes(valp, 2); /* B. */
show_bytes(valp, 3); /* C. */
/* $end simple-show-a */
}

void simple_show_b() {
/* $begin simple-show-b */
int val = 0x12345678;
byte_pointer valp = (byte_pointer) &amp;val;
show_bytes(valp, 1); /* A. */
show_bytes(valp, 2); /* B. */
show_bytes(valp, 3); /* C. */
/* $end simple-show-b */
}

void float_eg() {
  int x = 3490593;
  float f = (float) x;
  printf(&quot;For x = %d\n&quot;, x);
  show_int(x);
  show_float(f);

  x = 3510593;
  f = (float) x;
  printf(&quot;For x = %d\n&quot;, x);
  show_int(x);
  show_float(f);

}

void string_ueg() {
/* $begin show-ustring */
const char *s = &quot;ABCDEF&quot;;
show_bytes((byte_pointer) s, strlen(s)); 
/* $end show-ustring */
}

void string_leg() {
/* $begin show-lstring */
const char *s = &quot;abcdef&quot;;
show_bytes((byte_pointer) s, strlen(s)); 
/* $end show-lstring */
}

void show_twocomp() 
{
/* $begin show-twocomp */
    short x = 12345; 
    short mx = -x; 
    
    show_bytes((byte_pointer) &amp;x, sizeof(short)); 
    show_bytes((byte_pointer) &amp;mx, sizeof(short)); 
/* $end show-twocomp */
}

int main(int argc, char *argv[])
{
    int val = 12345;

    if (argc &gt; 1) {
        if (argc &gt; 1) {
            val = strtol(argv[1], NULL, 0);
        }
        printf(&quot;calling test_show_bytes\n&quot;);
        test_show_bytes(val);
    } else {
        printf(&quot;calling show_twocomp\n&quot;);
        show_twocomp();
        printf(&quot;Calling simple_show_a\n&quot;);
        simple_show_a();
        printf(&quot;Calling simple_show_b\n&quot;);
        simple_show_b();
        printf(&quot;Calling float_eg\n&quot;);
        float_eg();
        printf(&quot;Calling string_ueg\n&quot;);
        string_ueg();
        printf(&quot;Calling string_leg\n&quot;);
        string_leg();
    }
    return 0;
}

</code></pre>
<p>用 GCC 编译：</p>
<pre><code class="language-shell">// mac os 11.1
gcc -m64 show-bytes.c -o show-bytes
</code></pre>
<p>run 一下：</p>
<pre><code class="language-shell">./show-bytes
</code></pre>
<p>输出：</p>
<pre><code class="language-shell">calling show_twocomp
 39 30
 c7 cf
Calling simple_show_a
 21
 21 43
 21 43 65
Calling simple_show_b
 78
 78 56
 78 56 34
Calling float_eg
For x = 3490593
 21 43 35 00
 84 0c 55 4a
For x = 3510593
 41 91 35 00
 04 45 56 4a
Calling string_ueg
 41 42 43 44 45 46
Calling string_leg
 61 62 63 64 65 66
</code></pre>
<h2><a id="2-56" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.56</h2>
<p>可以在后面加参数，就可以试不同的示例值了：</p>
<pre><code class="language-shell">// 输入
./show-bytes 1

// 输出 顺便看出来是小端模式。
calling test_show_bytes
 01 00 00 00
 00 00 80 3f
 58 f9 14 e4 fe 7f 00 00

// 输入
./show-bytes 996

// 输出
calling test_show_bytes
 e4 03 00 00
 00 00 79 44
 58 79 ad ec fe 7f 00 00

</code></pre>
<h2><a id="2-57" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.57</h2>
<p>增加三个函数并修改测试函数：</p>
<pre><code class="language-c">void show_short(short x) {
  show_bytes((byte_pointer) &amp;x, sizeof(short));
}

void show_long(long x) {
  show_bytes((byte_pointer) &amp;x, sizeof(long));
}

void show_double(double x) {
  show_bytes((byte_pointer) &amp;x, sizeof(double));
}

void test_show_bytes(int val) {
    int ival = val;
    float fval = (float) ival;
    int *pval = &amp;ival;
    
    show_int(ival);
    show_float(fval);
    show_pointer(pval);
    
    short sval = (short) ival;
    long lval = (long) ival;
    double dval = (double) ival;

    show_short(sval);
    show_long(lval);
    show_double(dval);
}
</code></pre>
<p>重新编译，测试结果如下，注意最后三行输出是新加的：</p>
<pre><code class="language-shell">// 输入
./show-bytes 1

// 输出
calling test_show_bytes
 01 00 00 00
 00 00 80 3f
 58 39 b0 e5 fe 7f 00 00
 01 00
 01 00 00 00 00 00 00 00
 00 00 00 00 00 00 f0 3f

// 输入
./show-bytes 996

// 输出
calling test_show_bytes
 e4 03 00 00
 00 00 79 44
 58 a9 35 ed fe 7f 00 00
 e4 03
 e4 03 00 00 00 00 00 00
 00 00 00 00 00 20 8f 40

</code></pre>
<h2><a id="2-58" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.58</h2>
<pre><code class="language-c">/*
 * is-little-endian.c
 */

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

typedef unsigned char* byte_pointer;

int is_little_endian() {
  int test_num = 0xff;
  byte_pointer byte_start = (byte_pointer) &amp;test_num;

  if (byte_start[0] == 0xff) {
    return 1;
  }
  return 0;
}

int is_little_endian_other(){
    int a = 1;
    return *((char*)&amp;a);
}

int main(int argc, char* argv[]) {
  assert(is_little_endian());
  return 0;
}
</code></pre>
<h2><a id="2-59" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.59</h2>
<pre><code class="language-c">(x &amp; 0xFF) | (y &amp; ~0xFF)
</code></pre>
<h2><a id="2-60" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.60</h2>
<pre><code class="language-c">
/*
 * replace-byte.c
 */

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

unsigned replace_byte(unsigned x, int i, unsigned char b) {
  if (i &lt; 0) {
    printf(&quot;error: i is negetive\n&quot;);
    return x;
  }
  if (i &gt; sizeof(unsigned)-1) {
    printf(&quot;error: too big i&quot;);
    return x;
  }

  // 1 byte 有 8 bits， &lt;&lt; 3 就是 * 8
  unsigned mask = ((unsigned) 0xFF) &lt;&lt; (i &lt;&lt; 3);
  unsigned pos_byte = ((unsigned) b) &lt;&lt; (i &lt;&lt; 3);

  return (x &amp; ~mask) | pos_byte;
}

int main(int argc, char *argv[]) {
  unsigned rep_0 = replace_byte(0x12345678, 0, 0xAB);
  unsigned rep_3 = replace_byte(0x12345678, 3, 0xAB);

  assert(rep_0 == 0x123456AB);
  assert(rep_3 == 0xAB345678);
  return 0;
}

</code></pre>
<h2><a id="2-61" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.61</h2>
<pre><code class="language-c">
// A x 的任何位都等于 1
!~x

// B x 的任何位都等于 0
!x

// C x 的最高有效字节中的位都等于 1
!~(x &gt;&gt; ((sizeof(int) - 1) &lt;&lt; 3))

// D x 的最低有效字节中的位都等于 0
!(x &amp; 0xFF)

</code></pre>
<h2><a id="2-62" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.62</h2>
<pre><code class="language-c">/*
 * int-shifts-are-arithemetic.c
 */

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int int_shifts_are_arithemetic() {
  int num = -1;
  return !(num ^ (num &gt;&gt; 1));
}

int main(int argc, char* argv[]) {
  assert(int_shifts_are_arithemetic());
  return 0;
}
</code></pre>
<h2><a id="2-63" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.63</h2>
<pre><code class="language-c">/*
 * srl-sra.c
 */

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

// 将 xrsl 的第 w-k-1 位扩展到前 k 个高位
int sra(int x, int k) {
  int xsrl = (unsigned) x &gt;&gt; k;

  int w = sizeof(int) &lt;&lt; 3;
  // mask 的前 k 高位全是 1
  int mask = (int) -1 &lt;&lt; (w - k);
  // m 最高位是 1，其他都是 0
  int m = 1 &lt;&lt; (w - 1);
  // x &amp; m，确定符号位是 1 还是 0。
  // 然后如果符号位是 1，!(x &amp; m) 为 0，0 - 1 等于 -1，mask &amp;= -1 还是他本身。
  // 如果符号位是 0，!(x &amp; m) 为 1，1 - 1 等于 0，mask &amp;= 0 为 0。
  mask &amp;= !(x &amp; m) - 1;
  return xsrl | mask;
}

// 前 k 高位清零即可
unsigned srl(unsigned x, int k) {
  unsigned xsra = (int) x &gt;&gt; k;

  int w = sizeof(int) &lt;&lt; 3;
  int mask = (int) -1 &lt;&lt; (w - k);
  return xsra &amp; ~mask;
}

int main(int argc, char* argv[]) {
  unsigned test_unsigned = 0x12345678;
  int test_int = 0x12345678;

  assert(srl(test_unsigned, 4) == test_unsigned &gt;&gt; 4);
  assert(sra(test_int, 4) == test_int &gt;&gt; 4);

  test_unsigned = 0x87654321;
    test_int = 0x87654321;

    assert (srl (test_unsigned, 4) == test_unsigned &gt;&gt; 4);
    assert (sra (test_int, 4) == test_int &gt;&gt; 4);

  return 0;
}
</code></pre>
<h2><a id="2-64" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.64</h2>
<pre><code class="language-c">int any_even_one(unsigned x) {
    return !!(0x55555555 &amp; x);
}
</code></pre>
<h2><a id="2-65" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.65</h2>
<pre><code class="language-c">// x 的每个位进行异或，如果为 0 就说明是偶数个 1，如果为 1 就是奇数个 1 。
// 通过算数右移一半的位数，相当于把左半部分位数降低到和右半部分一致，只关心右半部分异或结果就好。
int even_ones(unsigned x){
    x ^= (x &gt;&gt; 16);
    x ^= (x &gt;&gt; 8);
    x ^= (x &gt;&gt; 4);
    x ^= (x &gt;&gt; 2);
    x ^= (x &gt;&gt; 1);
    return !(x &amp; 1);
} 
</code></pre>
<h2><a id="2-66" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.66</h2>
<p>实现掩膜，数位中只剩下最左边的 1，其他位都是 0。如果 x 为 0,那么函数返回 0。</p>
<p>利用移位操作，首先将 x 右移再或，分别利用<code>1,2,4,8,16</code>，得到从最左边的 1 后面全部为 1，然后再右移1位，取异或。</p>
<pre><code class="language-c">int leftmost_one(unsigned x) {
    x |= (x &gt;&gt; 1);
    x |= (x &gt;&gt; 2);
    x |= (x &gt;&gt; 4);
    x |= (x &gt;&gt; 8);
    x |= (x &gt;&gt; 16);
    return x^(x&gt;&gt;1);
}
</code></pre>
<h2><a id="2-67" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.67</h2>
<p>A：</p>
<p>If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior it undefined.</p>
<p>32位机器上没有定义移位32次，所以需要分多次左移。</p>
<pre><code class="language-c">/*
 * int-size-is-32.c
 */

#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

/* The following function does not run properly on some machine */
/*
int bad_int_size_is_32() {
  int set_msb = 1 &lt;&lt; 31;
  int beyond_msb = 1 &lt;&lt; 32;

  return set_msb &amp;&amp; !beyond_msb;
}
*/

int int_size_is_32() {
  int set_msb = 1 &lt;&lt; 31;
  int beyond_msb = set_msb &lt;&lt; 1;

  return set_msb &amp;&amp; !beyond_msb;
}

int int_size_is_32_for_16bit() {
  int set_msb = 1 &lt;&lt; 15 &lt;&lt; 15 &lt;&lt; 1;
  int beyond_msb = set_msb &lt;&lt; 1;

  return set_msb &amp;&amp; !beyond_msb;
}

int main(int argc, char *argv[]) {
  assert(int_size_is_32());
  assert(int_size_is_32_for_16bit());
  return 0;
}

</code></pre>
<h2><a id="2-68" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.68</h2>
<p>让 x 的最低 n 位变 1。</p>
<pre><code class="language-c">/*
 * lower-one-mask.c
 */
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

/*
 * Mask with least signficant n bits set to 1
 * Example: n = 6 -&gt; 0x3F, n = 17 -&gt; 0x1FFFF
 * Assume 1 &lt;= n &lt;= w
 */
int lower_one_mask(int n) {
  int w = sizeof(int) &lt;&lt; 3;
  return (unsigned) -1 &gt;&gt; (w - n);
}

int main(int argc, char* argv[]) {
  assert(lower_one_mask(6) == 0x3F);
  assert(lower_one_mask(17) == 0x1FFFF);
  assert(lower_one_mask(32) == 0xFFFFFFFF);
  return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Module 如何被全局引用]]></title>
    <link href="www.dreameverafter.com/17001892555760.html"/>
    <updated>2023-11-17T10:47:35+08:00</updated>
    <id>www.dreameverafter.com/17001892555760.html</id>
    <content type="html"><![CDATA[
<p>今天一个iOS大佬问我一个小问题，他用 <code>cocoapods</code> 集成了一个 <code>swift</code> 的 <code>json</code> 库：<code>SwiftyJSON</code>，用的时候发现有一丝丝不方便的地方，就是在每个用到 <code>SwiftyJSON</code> 的文件中，都需要 <code>import</code> 一下这个 <code>module</code>。</p>
<span id="more"></span><!-- more -->
<p>平时他在主工程里写代码的时候，由于都在一个 <code>module</code> 之下，所以基本上没有怎么用过 <code>import</code> 了，所以问我为什么会这样，以及有没有一个类似于 <code>PCH</code> 的文件，把 <code>SwiftyJSON</code> 全局引用。</p>
<p>至于为什么会这样，其实刚刚已经说了，就是因为没有在一个 <code>module</code> 中嘛。有没有类似 <code>PCH</code> 的东西呢，其实也是有的。</p>
<p>可以直接创建一个 <code>swift</code> 文件（类似 <code>PCH</code> ），在这个文件中使用 <code>@_exported import</code> 来导入：</p>
<pre><code class="language-swift">@_exported import SwiftyJSON 
</code></pre>
<p>这就好了，没错，智慧就是这么简单。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 398  随机数索引]]></title>
    <link href="www.dreameverafter.com/17001875302574.html"/>
    <updated>2023-11-17T10:18:50+08:00</updated>
    <id>www.dreameverafter.com/17001875302574.html</id>
    <content type="html"><![CDATA[
<p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p>
<p>注意：</p>
<p>数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p>
<span id="more"></span><!-- more -->
<p>示例:</p>
<pre><code class="language-plain_text">int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。
solution.pick(3);

// pick(1) 应该返回 0。因为只有nums[0]等于1。
solution.pick(1);
</code></pre>
<p>解：</p>
<p>(蓄水池抽样)</p>
<p>利用一个unordered_map&lt;int, vector<int>&gt; um存储每个数值对应的下标，那么随机返回一个索引，其实就是生成一个0-um[target].size() - 1的一个随机数，这样如果存在多次pick，那么每次都是O(1)O(1)的效率。</p>
<pre><code class="language-c++">class Solution {
public:

    unordered_map&lt;int, vector&lt;int&gt;&gt; um;
    
    Solution(vector&lt;int&gt;&amp; nums) {
        for (int i = 0; i &lt; nums.size(); i ++) {
            um[nums[i]].push_back(i);
        }
    }
    
    int pick(int target) {
        return um[target][rand() % um[target].size()];
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * int param_1 = obj-&gt;pick(target);
 */

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[水仙 🌼]]></title>
    <link href="www.dreameverafter.com/17001150891969.html"/>
    <updated>2023-11-16T14:11:29+08:00</updated>
    <id>www.dreameverafter.com/17001150891969.html</id>
    <content type="html"><![CDATA[
<p>买个安卓手机做导航用的，没成想到手第一件事就是装了个ons模拟器，然后一晚上把水仙1和2玩完了。</p>
<span id="more"></span><!-- more -->
<p><img src="media/17001150891969/17001182613721.png" alt="水仙" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《十万嬉皮》]]></title>
    <link href="www.dreameverafter.com/17001174848432.html"/>
    <updated>2023-11-16T14:51:24+08:00</updated>
    <id>www.dreameverafter.com/17001174848432.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>万能青年旅店</p>
</blockquote>
<span id="more"></span><!-- more -->
<p>大梦一场的董二千先生</p>
<p>推开窗户 举起望远镜</p>
<p>眼底映出 一阵浓烟</p>
<p>前已无通路 后不见归途</p>
<p>敌视现实 虚构远方</p>
<p>东张西望 一无所长</p>
<p>四体不勤 五谷不分</p>
<p>文不能测字 武不能防身</p>
<p>喜欢养狗 不爱洗头</p>
<p>不事劳作 一无所获</p>
<p>厌恶争执 不善言说</p>
<p>终于沦为沉默的帮凶</p>
<p>借酒消愁 不太能喝</p>
<p>蛊惑他人 麻醉内心</p>
<p>浇上汽油 舒展眉头</p>
<p>纵火的青年 迫近的时间</p>
<p>大梦一场的董二千先生</p>
<p>推开窗户 举起望远镜</p>
<p>眼底映出 一阵浓烟</p>
<p>前已无通路 后不见归途</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vue 的一些指令和缩写]]></title>
    <link href="www.dreameverafter.com/17001187952144.html"/>
    <updated>2023-11-16T15:13:15+08:00</updated>
    <id>www.dreameverafter.com/17001187952144.html</id>
    <content type="html"><![CDATA[
<p>这里得先了解一下vue中的指令(Directives)。</p>
<span id="more"></span><!-- more -->
<p>指令是带有 <code>v-</code> 前缀的特殊 <code>attribute</code>。指令 <code>attribute</code> 的值预期是 <strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：</p>
<pre><code class="language-html">&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;
</code></pre>
<p>这里，<code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来插入/移除 <code>&lt;p&gt;</code> 元素。</p>
<p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，<code>v-</code> 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。</p>
<p>同时，在构建由 Vue 管理所有模板的 <strong>单页面应用程序 (SPA - single page application)</strong> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写。</p>
<h2><a id="" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>$</code></h2>
<p>Vue 实例暴露了一些有用的实例属性与方法。它们都有前缀 <code>$</code>，以便与用户定义的属性区分开来，避免Vue的属性被用户自定义的属性覆盖。</p>
<h2><a id="%EF%BC%8Cv-bind%E7%BC%A9%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>:</code>，<code>v-bind</code> 缩写</h2>
<pre><code class="language-html">&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h2><a id="%EF%BC%8Cv-on%E7%BC%A9%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>@</code>，<code>v-on</code> 缩写</h2>
<pre><code class="language-html">&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;
&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre>
<h2><a id="v-for" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>v-for</code></h2>
<h3><a id="%E7%94%A8v-for%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E5%BA%94%E4%B8%BA%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用<code>v-for</code>把一个数组对应为一组元素</h3>
<p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p>
<pre><code class="language-html">&lt;ul id=&quot;example-1&quot;&gt;
  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>在 <code>v-for</code> 块中，我们可以访问所有父作用域的 property。<code>v-for</code> 还支持一个可选的第二个参数，即当前项的索引。</p>
<pre><code class="language-html">&lt;ul id=&quot;example-2&quot;&gt;
  &lt;li v-for=&quot;(item, index) in items&quot;&gt;
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>你也可以用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p>
<pre><code class="language-html">&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;
</code></pre>
<h3><a id="%E5%9C%A8v-for%E9%87%8C%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在 <code>v-for</code> 里使用对象</h3>
<p>你也可以用 <code>v-for</code> 来遍历一个对象的 property。</p>
<pre><code class="language-html">&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<pre><code class="language-js">new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
</code></pre>
<p>还可以用第三个参数作为索引：</p>
<pre><code class="language-html">&lt;div v-for=&quot;(value, name, index) in object&quot;&gt;
  {{ index }}. {{ name }}: {{ value }}
&lt;/div&gt;
</code></pre>
<p>在遍历对象时，会按 <code>Object.keys()</code> 的结果遍历，但是<strong>不能</strong>保证它的结果在不同的 JavaScript 引擎下都一致。</p>
<h3><a id="%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>维护状态</h3>
<p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code>。</p>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> attribute：</p>
<pre><code class="language-html">&lt;div v-for=&quot;item in items&quot; v-bind:key=&quot;item.id&quot;&gt;
  &lt;!-- 内容 --&gt;
&lt;/div&gt;
</code></pre>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
<p>不要使用对象或数组之类的非基本类型值作为 <code>v-for</code> 的 <code>key</code>。请用字符串或数值类型的值。</p>
<p>更多 <code>key</code> attribute 的细节用法请移步至 <a href="https://cn.vuejs.org/v2/api/#key"><code>key</code> 的 API 文档</a>。</p>
<h3><a id="%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数组更新检测</h3>
<p>变更方法：Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<p>你可以打开控制台，然后对前面例子的 <code>items</code> 数组尝试调用变更方法。比如 <code>example1.items.push({ message: 'Baz' })</code>。</p>
<p>替换数组：变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 <code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>。当使用非变更方法时，可以用新数组替换旧数组：</p>
<pre><code class="language-js">example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})
</code></pre>
<p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。</p>
<p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。</p>
<h3><a id="%E5%9C%A8template%E4%B8%8A%E4%BD%BF%E7%94%A8-v-for" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在 <code>&lt;template&gt;</code> 上使用 <code>v-for</code></h3>
<p>类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。比如：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;template v-for=&quot;item in items&quot;&gt;
    &lt;li&gt;{{ item.msg }}&lt;/li&gt;
    &lt;li class=&quot;divider&quot; role=&quot;presentation&quot;&gt;&lt;/li&gt;
  &lt;/template&gt;
&lt;/ul&gt;
</code></pre>
<h3><a id="v-for%E4%B8%8E-v-if%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>v-for</code> 与 <code>v-if</code> 一同使用</h3>
<p>注意我们<strong>不</strong>推荐在同一元素上使用 <code>v-if</code> 和 <code>v-for</code>。</p>
<p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当你只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用，如下：</p>
<pre><code class="language-html">&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;
  {{ todo }}
&lt;/li&gt;
</code></pre>
<p>上面的代码将只渲染未完成的 todo。</p>
<p>而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>) 上。如：</p>
<pre><code class="language-html">&lt;ul v-if=&quot;todos.length&quot;&gt;
  &lt;li v-for=&quot;todo in todos&quot;&gt;
    {{ todo }}
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p v-else&gt;No todos left!&lt;/p&gt;
</code></pre>
<blockquote>
<p>参考： <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode 486 Predict the Winner(预测赢家)]]></title>
    <link href="www.dreameverafter.com/17001875302498.html"/>
    <updated>2023-11-17T10:18:50+08:00</updated>
    <id>www.dreameverafter.com/17001875302498.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%A2%98%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>题目</h2>
<p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<span id="more"></span><!-- more -->
<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>
<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>
<p>示例 1：</p>
<pre><code class="language-plain_text">输入：[1, 5, 2]
输出：False
解释：一开始，玩家1可以从1和2中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False 。
</code></pre>
<p>示例 2：</p>
<pre><code class="language-plain_text">输入：[1, 5, 233, 7]
输出：True
解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。
</code></pre>
<p>提示：</p>
<ul>
<li>1 &lt;= 给定的数组长度 &lt;= 20.</li>
<li>数组里所有分数都为非负数且不会大于 10000000 。</li>
<li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li>
</ul>
<h2><a id="%E8%A7%A3%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解题</h2>
<p>设：总分 = 先手得分 - 后手得分。</p>
<p>当所有分数都被拿走后，如果总分&gt;=0，就是先手胜，反之就是后手胜利。</p>
<p>由于是两个人分别拿，所以需要 <code>turn</code> 的正负来表示先手还是后手，在所有计算分数的地方都乘以 <code>turn</code>，使得总分就是差值。</p>
<p>最直观的思路就是用递归做出来，设数组两头的下标为 <code>start</code> 和 <code>end</code>。</p>
<p>递归函数中分别选择一个下标，计算选择下标之后递归计算出数组剩下的分被选择后的总分。</p>
<p>下标的分加上剩下的总分共有两种情况，取最大值，就是当前递归函数的总分。</p>
<p>递归中止条件为 <code>start == end</code>， 这时候直接返回当前下标的值就好了。</p>
<h2><a id="%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归解法</h2>
<p>解：</p>
<pre><code class="language-cpp">
class Solution {
public:
    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) {
        return total(nums, 0, nums.size() - 1, 1) &gt;= 0;
    }

    int total(vector&lt;int&gt;&amp; nums, int start, int end, int turn) {
        if (start == end) {
            return nums[start] * turn;
        }
        int scoreStart = nums[start] * turn + total(nums, start + 1, end, -turn);
        int scoreEnd = nums[end] * turn + total(nums, start, end - 1, -turn);
        return max(scoreStart * turn, scoreEnd * turn) * turn;
    }
};

</code></pre>
<p>时间复杂度：<code>O(2^n)</code>，其中 <code>n</code> 是数组的长度。</p>
<p>空间复杂度：O(n)，其中 <code>n</code> 是数组的长度。空间复杂度取决于递归使用的栈空间。</p>
<h2><a id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态规划解法</h2>
<p>使用递归，存在大量重复计算，因此时间复杂度很高。可以试用动归解决这个问题。</p>
<p>用一个二维数组，记录计算过的总分。</p>
<p><code>dp[i][j]</code> 为当前玩家在数组中，下标 <code>i</code> 到下标 <code>j</code> 的分数之差的最大值，当前玩家不一定是先手玩家。</p>
<p>根据题意，i不可能大于j。</p>
<p>当i==j时，dp[i][j] = nums[i];</p>
<p>计算分数的之差的最大值（状态转移）的公式是：</p>
<pre><code class="language-cpp">dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
</code></pre>
<p>注意状态转移的方向，保证依赖的值已经有解。</p>
<pre><code class="language-cpp">class Solution {
public:
    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
        auto dp = vector&lt;vector&lt;int&gt;&gt; (length, vector&lt;int&gt;(length));
        for (int i = 0; i &lt; length; i++) {
            dp[i][i] = nums[i];
        }
        // - 2是因为i == length - 1，这个值在刚刚已经算过了，只有一个值，即dp[i][i]
        for (int i = length - 2; i &gt;= 0; i--) {
            for (int j = i + 1; j &lt; length; j++) {
                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
            }
        }
        return dp[0][length - 1] &gt;= 0;
    }
};
</code></pre>
<p>经过观察，<code>dp[i][j]</code> 的值只和 <code>dp[i+1][j]</code> 与 <code>dp[i][j−1]</code> 有关。</p>
<p>即在计算第 <code>i</code> 行的值时，只使用到 <code>dp</code> 的第 <code>i</code> 行和第 <code>i+1</code> 行的值，而 <code>j=i+1</code> ，所以大于 <code>i+1</code> 后面的行，都用不到了，可以借给 <code>j</code> 用。</p>
<p>列也只在意 <code>j</code> 和 <code>j - 1</code> 的值，所以就可以用一个数组来记录。</p>
<p>可以优化一下空间，把二维数组换成一维数组。</p>
<pre><code class="language-cpp">class Solution {
public:
    bool PredictTheWinner(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
        auto dp = vector&lt;int&gt;(length);
        for (int i = 0; i &lt; length; i++) {
            dp[i] = nums[i];
        }
        for (int i = length - 2; i &gt;= 0; i--) {
            for (int j = i + 1; j &lt; length; j++) {
                dp[j] = max(nums[i] - dp[j], nums[j] - dp[j - 1]);
            }
        }
        return dp[length - 1] &gt;= 0;
    }
};
</code></pre>
<p>时间复杂度：<code>O(n^2)</code>，其中 <code>n</code> 是数组的长度。需要计算每个子数组对应的 <code>dp</code> 的值，共有 <code>n(n+1)/2</code> 个子数组。</p>
<p>空间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组的长度。空间复杂度取决于额外创建的数组 <code>dp</code>，如果不优化空间，则空间复杂度是 <code>O(n^2)</code>，使用一维数组优化之后空间复杂度可以降至 <code>O(n)</code>。</p>

]]></content>
  </entry>
  
</feed>
