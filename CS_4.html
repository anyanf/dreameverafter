<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  CS - DreamEverAfter
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="DreamEverAfter" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.dreameverafter.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="tools.html">工具</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; DreamEverAfter</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="tools.html">工具</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Pages.html">Pages</a></li>
        
            <li><a href="CS.html">CS</a></li>
        
            <li><a href="List.html">List</a></li>
        
            <li><a href="%E6%9D%82.html">杂</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="17001188677503.html">
                
                  <h1>centos7 mysql数据库安装和配置</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>去年趁有优惠活动租了个腾讯云，之前搭了Wordpress，用了一段时间后感觉不太好用，还是转回Hugo了，然后这个服务器就一直闲置了，最近一段时间从各种途径得到了三本关于mysql的书，猛然发觉上次写sql已经是快三年前的事了，东西又快忘光了，遂准备把这三本书撸一遍，正好用这个服务器搭一个mysql，在服务器上练习。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="17001188677503.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/03/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='CS.html'>CS</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892554959.html">
                
                  <h1>Fishhook-源码分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1><a id="fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fishhook-源码分析</h1>
<p>看腾讯开源的iOS内存监控组件<a href="https://github.com/Tencent/OOMDetector">OOMDetector</a>的过程中，发现其内部使用了Facebook开源的<a href="https://github.com/facebook/fishhook">fishhook</a>。遂跟着研究了一下这个库。</p>
<p>fishhook可以在模拟器和设备上的iOS上运行的Mach-O二进制文件中动态重新绑定符号，可以交换C的函数。</p>
<p>fishhook代码量不多，一共就两个文件fishhook.h和fishhook.c。其中.c文件只有200多行，整体所以看起来不是很复杂的，不过其中涉及到了 <code>Mach-O</code> 和函数指针相关的知识，想看懂这些代码还是需要一些基础的。</p>
<p>先看一下调用流程。</p>
<h2><a id="%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用流程</h2>
<pre><code class="language-c">int rebind_symbols_image(void *header,
                         intptr_t slide,
                         struct rebinding rebindings[],
                         size_t rebindings_nel);

int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);
</code></pre>
<p>这两个函数是暴漏在.h，给用户调用的，其内部都是直接或者间接调用了</p>
<pre><code class="language-c">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,
                                     const struct mach_header *header,
                                     intptr_t slide);
</code></pre>
<p>接着最终调用</p>
<pre><code class="language-c">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,
                                           section_t *section,
                                           intptr_t slide,
                                           nlist_t *symtab,
                                           char *strtab,
                                           uint32_t *indirect_symtab);
</code></pre>
<p>大概流程就是这样了，其中在<code>perform_rebinding_with_section</code>函数中这段代码是交换函数的地方</p>
<pre><code class="language-c">if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;
    indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) {
    *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];
}
indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;
</code></pre>
<h2><a id="%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8%EF%BC%88oomdetector%E4%B8%AD%E6%9B%BF%E6%8D%A2malloc%E7%AD%89%E5%87%BD%E6%95%B0%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实例应用（OOMDetector中替换malloc等函数）</h2>
<p>此实例是OOMDetector使用fishhook替换malloc函数。</p>
<p>下面的替换malloc等函数的入口函数<code>hookMalloc</code>，该函数调用了OOMDetector的<code>rebind_symbols_for_imagename</code>函数。</p>
<pre><code class="language-c">void hookMalloc()
{
    if(!isPaused){
        beSureAllRebindingFuncBeenCalled();
        
        orig_malloc = malloc;
        orig_calloc = calloc;
        orig_valloc = valloc;
        orig_realloc = realloc;
        orig_block_copy = _Block_copy;
        rebind_symbols_for_imagename(
                                     (struct rebinding[5]){
                                                        {&quot;realloc&quot;,(void*)new_realloc,(void**)&amp;orig_realloc},
                                                        {&quot;malloc&quot;, (void*)new_malloc, (void **)&amp;orig_malloc},
                                                        {&quot;valloc&quot;,(void*)new_valloc,(void**)&amp;orig_valloc},
                                                        {&quot;calloc&quot;,(void*)new_calloc,(void**)&amp;orig_calloc},
                                                        {&quot;_Block_copy&quot;,(void*)new_block_copy,(void**)&amp;orig_block_copy}},
                                     5,
                                     getImagename());
    }
    else{
        isPaused = false;
    }

}
</code></pre>
<p><code>hookMalloc</code>替换了<code>realloc</code>、<code>malloc</code>、<code>valloc</code>、<code>calloc</code>、<code>_Block_copy</code>这几个函数。</p>
<p>下面是新的<code>new_malloc</code>函数定义：</p>
<pre><code class="language-c">static void* (*orig_malloc)(size_t);
static void* (*orig_calloc)(size_t, size_t);
static void* (*orig_realloc)(void *, size_t);
static void* (*orig_valloc)(size_t);
static void* (*orig_block_copy)(const void *aBlock);
</code></pre>
<p>下面是<code>rebind_symbols_for_imagename</code>第三个入参————镜像名称的获取方式：</p>
<pre><code class="language-c">const char *getImagename()
{
    const char* name = _dyld_get_image_name(0);
    const char* tmp = strrchr(name, '/');
    if (tmp) {
        name = tmp + 1;
    }
    return name;
}
</code></pre>
<p>调用了<code>&lt;mach-o/dyld.h&gt;</code> 头文件中的<code>_dyld_get_image_name</code>函数。 <code>_dyld_get_image_name</code> 根据镜像的索引，获取镜像的名称。<code>strrchr</code>函数是反向查找第一个给定字符。返回第一次匹配到的地址指针。</p>
<p><code>rebind_symbols_for_imagename</code>函数是调用了fishhook中的<code>rebind_symbols_image</code>函数实现了函数的交换。</p>
<pre><code class="language-c">void rebind_symbols_for_imagename(struct rebinding rebindings[],
                                  size_t rebindings_nel,
                                  const char *imagename)
{
    uint32_t count = _dyld_image_count();
    for (uint32_t i = 0; i &lt; count; i++) {
        const mach_header_t* header = (const mach_header_t*)_dyld_get_image_header(i);
        const char* name = _dyld_get_image_name(i);
        const char* tmp = strrchr(name, '/');
        long slide = _dyld_get_image_vmaddr_slide(i);
        if (tmp) {
            name = tmp + 1;
        }
        if(strcmp(name,imagename) == 0){
            rebind_symbols_image((void *)header,
                                 slide,
                                 rebindings,
                                 rebindings_nel);
            break;
        }
    }
}

</code></pre>
<p><code>rebindings</code>承载重新绑定的所有信息，<code>rebindings_nel</code>是<code>rebindings</code>的个数，<code>imagename</code>要替换函数指针镜像名称，也就是只替换名称为<code>imagename</code>文件中的函数指针，其他库不做替换。</p>
<p><code>_dyld_get_image_header</code> 获取镜像的header头，<code>_dyld_get_image_vmaddr_slide</code>获取镜像的随机启动地址。<code>rebind_symbols_image</code>函数为重新绑定做准备，增加了两个参数，header、slide。header就是加载到内存的中二进制文件的头。slide 的是ALSR技术中的随机启动地址。这个地址的含义可以参考<a href="https://stackoverflow.com/questions/13574933/ios-crash-reports-atos-not-working-as-expected/13576028#13576028">iOS crash reports: atos not working as expected</a>、 <a href="https://www.cnblogs.com/feng9exe/p/7988360.html">iOS crash log 解析 symbol address = stack address - slide 运行时获取slide的api 利用dwarfdump从dsym文件中得到symbol</a> 。</p>
<h3><a id="%E5%85%B3%E4%BA%8Ealsr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于ALSR</h3>
<p>下面为了理解ALSR中的slide，贴出一段测试代码：</p>
<pre><code class="language-c">void understandALSR()
{
    ///枚举所有镜像
    for (int i = 0; i &lt; _dyld_image_count(); i++)
    {
        char *image_name = (char *)_dyld_get_image_name(i);
        const struct mach_header *mh = _dyld_get_image_header(i);
        intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i);
        
        printf(&quot;Image name %s ,image header 0x%llx , ASLR slide 0x%lx.\n&quot;,
               image_name, (mach_vm_address_t)mh, vmaddr_slide);
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code class="language-plain_text">Image name /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/dyld_sim ,image header 0x107ca6000 , ASLR slide 0x107ca6000.

Image name /Users/ankang/Library/Developer/CoreSimulator/Devices/C9991234-7FA4-4F9E-9C73-629AFC886DC1/data/Containers/Bundle/Application/5C4118B1-2236-4A9C-B0A3-0DF77D765054/LearnMachO.app/LearnMachO ,image header 0x107c9c000 , ASLR slide 0x7c9c000.
</code></pre>
<p>代码对应的二进制文件中的加载地址（链接时load address）示意图：</p>
<p><img src="media/17001892554959/17001910799965.jpg" alt="macho01" /></p>
<p><img src="media/17001892554959/17001910799978.jpg" alt="macho02" /></p>
<p>结合上面的示例代码和二进制内容图片，可以诠释下面的公式：</p>
<pre><code class="language-c">slide = (运行时)load address - (链接时)load address;
symble address ＝ stack address - slide；
</code></pre>
<p>其中：</p>
<ol>
<li>stack address ： 程序运行时线程栈中所有函数调用的地址。</li>
<li>symble address ： dsym文件中函数符号对应的地址，用此地址在dsym文件中可以查出对应的符号信息。</li>
</ol>
<p>可以看出，没有ASLR时：</p>
<pre><code class="language-plain_text">symble address =  stack address
</code></pre>
<h2><a id="%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码分析</h2>
<p>fishhook代码这么少，所以可以进行一次全面的分析了。</p>
<p>首先，fishhook定义了一个结构体，存储绑定的数据。定义如下：</p>
<pre><code class="language-c">/*
 * A structure representing a particular intended rebinding from a symbol
 * name to its replacement
 */
struct rebinding {
  const char *name;  `  //替换的函数名字
  void *replacement;	//替换后的函数指针
  void **replaced;      //原始的方法
};
</code></pre>
<p>接着看<code>rebind_symbols_image</code>函数：</p>
<pre><code class="language-c">int rebind_symbols_image(void *header,
                         intptr_t slide,
                         struct rebinding rebindings[],
                         size_t rebindings_nel) {
    struct rebindings_entry *rebindings_head = NULL;
    int retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);
    rebind_symbols_for_image(rebindings_head, (const struct mach_header *) header, slide);
    if (rebindings_head) {
      free(rebindings_head-&gt;rebindings);
    }
    free(rebindings_head);
    return retval;
}
</code></pre>
<p><code>rebind_symbols_image</code> 主要工作是通过<code>prepend_rebindings</code>构造绑定的结构体<code>struct rebindings_entry</code>，定义如下：</p>
<pre><code class="language-c">struct rebindings_entry {
  struct rebinding *rebindings;
  size_t rebindings_nel;
  struct rebindings_entry *next;
};

static int prepend_rebindings(struct rebindings_entry **rebindings_head,
                              struct rebinding rebindings[],
                              size_t nel) {
  // 申请new_entry地址  
  struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry));
  if (!new_entry) {
    return -1;
  }
  // 给new_entry-&gt;rebindings分配内存
  new_entry-&gt;rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel);
  if (!new_entry-&gt;rebindings) {
    free(new_entry);
    return -1;
  }
  // 拷贝重新绑定信息到new_entry-&gt;rebindings  
  memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel);
  new_entry-&gt;rebindings_nel = nel;
  new_entry-&gt;next = *rebindings_head;
    
  // 这个将创建的new_entry赋值给rebindings_head，通过二级指针返回给调用者
  *rebindings_head = new_entry;
  return 0;
}
</code></pre>
<p><code>prepend_rebindings</code>只是将绑定的<code>struct rebinding</code>类型参数转化为<code>struct rebindings_entry</code>结构，这种结构类似链表，可以方便的管理多个<code>struct rebinding</code>结构。下面看<code>rebind_symbols_for_image</code>：</p>
<pre><code class="language-c">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,
                                     const struct mach_header *header,
                                     intptr_t slide) {
  Dl_info info;
  // find the image containing a given address
  // 验证库是否存在
  if (dladdr(header, &amp;info) == 0) {
    return;
  }

  segment_command_t *cur_seg_cmd;
  
  // SEG_LINKEDIT commond指针
  segment_command_t *linkedit_segment = NULL;
  // LC_SYMTAB commond指针
  struct symtab_command* symtab_cmd = NULL;
  // LC_DYSYMTAB commond指针
  struct dysymtab_command* dysymtab_cmd = NULL;
	
  // 定位linkedit_segment、symtab_cmd、dysymtab_cmd三指针
  uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);
  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize)
  {
    cur_seg_cmd = (segment_command_t *)cur;
    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)
    {
      if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0)
      {
        linkedit_segment = cur_seg_cmd;
      }
    }
    else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB)
    {
      symtab_cmd = (struct symtab_command*)cur_seg_cmd;
    }
    else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB)
    {
      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;
    }
  }

  if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||
      !dysymtab_cmd-&gt;nindirectsyms) {
    return;
  }

  // Find base symbol/string table addresses 查找符号表和string表
  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;
  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);
  char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);

  // Get indirect symbol table (array of uint32_t indices into symbol table)
  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);

  cur = (uintptr_t)header + sizeof(mach_header_t);
  
  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) 
  {
    cur_seg_cmd = (segment_command_t *)cur;
    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)
    {
      if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp;
          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) {
        continue;
      }
      // 找到类型为S_LAZY_SYMBOL_POINTERS、S_NON_LAZY_SYMBOL_POINTERS类型的section
      for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) {
        section_t *sect =
          (section_t *)(cur + sizeof(segment_command_t)) + j;
        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) {
          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);
        }
        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) {
          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);
        }
      }
    }
  }
}
</code></pre>
<p><code>rebind_symbols_for_image</code> 函数主要定位到三表，类型为<code>S_LAZY_SYMBOL_POINTERS</code>、<code>S_NON_LAZY_SYMBOL_POINTERS</code>类型的section。然后调用<code>perform_rebinding_with_section</code> 函数。其中部分宏定义如下。</p>
<pre><code class="language-c">#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64
#define	SEG_LINKEDIT	&quot;__LINKEDIT&quot;
#define	S_NON_LAZY_SYMBOL_POINTERS 0x6  /* section with only non-lazy symbol pointers */
#define	S_LAZY_SYMBOL_POINTERS 0x7     /* section with only lazy symbol
</code></pre>
<p>上面的宏定义于<code>&lt;mach-o/loader.h&gt;</code>文件中，位于477行。 在<code>S_NON_LAZY_SYMBOL_POINTERS</code>宏的上面有一段注释。这段注释非常的关键。说明了<code>S_NON_LAZY_SYMBOL_POINTERS</code>类型的section中的数据和动态符号表中的符号是顺序对应的。只有理解了这段内容。才能真正的理解fishhook。</p>
<p>For the two types of symbol pointers sections and the symbol stubs section they have indirect symbol table entries.</p>
<p>对于存储符号指针、符号存根两种类型的section，它们有间接符号表条目。</p>
<p>For each of the entries in the section,the indirect symbol table entries, in corresponding order in the indirect symbol table, start at the index stored in the reserved1 field of the section structure.</p>
<p>间接符号表条目顺序对应section中的条目，对应从section的reserved1索引开始。</p>
<p>Since the indirect symbol table entries correspond to the entries in the section the number of indirect symbol table entries is inferred from the size of the section divided by the size of the entries in the section. For symbol pointers sections the size of the entries in the section is 4 bytes (看结构是8bytes，可能是64位的缘故)</p>
<p>由于间接符号表条目对应于section中的条目，因此间接符号表条目的数量由section的大小除以section中的条目的大小来推断。对于符号指针节，section中的条目的大小是4个字节</p>
<p>下面是<code>perform_rebinding_with_section</code>函数源码：</p>
<pre><code class="language-c">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,
                                           section_t *section,  // section
                                           intptr_t slide,     // 基址
                                           nlist_t *symtab,  // 符号表
                                           char *strtab,  // sting 表
                                           uint32_t *indirect_symtab // 动态符号表
                                           )
{
    // 动态符号表 对应section的地址，动态符号表的基地址+section对应的偏移量
    uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;

    // section加载到内存的虚拟地址（是要替换这里面的东西）
    void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr);
    
    // section中替换函数指针
    for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++)
    {
        // 由于section中条目和动态符号表中的条目对应，所以将section中的条目索引i用于动态符号表。
        // 下面目的是获取section中存储的函数指针的符号  动态符号表-&gt; 符号表-&gt; string表
        
        // indirect_symbol_indices[i]中存储符号表的索引。symtab_index就是符号表的索引
        uint32_t symtab_index = indirect_symbol_indices[i];
        if (symtab_index == INDIRECT_SYMBOL_ABS || 
            symtab_index == INDIRECT_SYMBOL_LOCAL ||
            symtab_index == (INDIRECT_SYMBOL_LOCAL | 
                             INDIRECT_SYMBOL_ABS))
        {
            continue;
        }
        // 通过nlist_t的n_strx找到String表的偏移地址，strtab_offset。
        uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;
        char *symbol_name = strtab + strtab_offset;
        if (strnlen(symbol_name, 2) &lt; 2)
        {
            continue;
        }
        
        ///依次枚举struct rebindings_entry 结构，判断时候有和当前函数指针相等的带替换的函数。
        struct rebindings_entry *cur = rebindings;
        while (cur)
        {
            for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++)
            {
                ///如果符号名称和替换的名称一样，进行替换
                if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0)
                {
                    if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;
                      indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement)
                    {
                        ///保存原始的指针地址，只保存一次
                        *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];
                    }
                    ///在section中替换。将indirect_symbol_bindings[i]中存储的函数指针地址进行替换。   
                    indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;
                    goto symbol_loop;
                }
            }
            cur = cur-&gt;next;
        }
        symbol_loop:;
    }
}
</code></pre>
<p><code>perform_rebinding_with_section</code>函数完成替换的关键函数。 将section中的函数指针替换为新的函数指针。</p>
<h2><a id="%E5%9B%BE%E8%A7%A3fishhook" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图解fishhook</h2>
<p>同事画的9张图片解释fishhook原理，看代码懵逼的可以看看图，有助于理解</p>
<p><img src="media/17001892554959/17001910799995.jpg" alt="" /></p>
<p>图1. load command中_DATA segement中<code>__la_symbol_ptr</code> section结构图,说明该section和动态符号表对应的起始索引是146</p>
<p><img src="media/17001892554959/17001910800014.jpg" alt="" /></p>
<p>图2.数据区域中<code>__la_symbol_ptr</code>的结构,可以看出该section的起始地址是0x00240B0，图2和图3是为了找malloc函数指针的位置</p>
<p><img src="media/17001892554959/17001910800040.jpg" alt="" /></p>
<p>图3.数据区域中__la_symbol_ptr的结构, 偏移了一定的位置。文件0x000242B0地址出存储的是malloc函数指针。</p>
<p>计算偏移数量的方法：0x242B0 - 0x240B0 = 0x200<br />
每个条目占用8个字节0x200/0x8 = 0x40 = 64<br />
得出：在符号表中，malloc偏移64个条目</p>
<p><img src="media/17001892554959/17001910800072.jpg" alt="" /></p>
<p>图4 .转到数据区域中动态符号表的起始位置处，该图说明动态符号表的起始地址是0x3B0A4</p>
<p><img src="media/17001892554959/17001910800110.jpg" alt="" /></p>
<p>图5 。 计算<strong>la_symbol_ptr 对应的符号在动态符号表中的位置： 0x3B060 + 146*4 = 0x3B060 + 0x248 = 0x3B2A8，地址0x0003B2A8处后面的符号和</strong>la_symbol_ptr中的条目对应。</p>
<p><img src="media/17001892554959/17001910800152.jpg" alt="" /></p>
<p>图6 . 查找64个偏移后的动态符号表的地址：0x3B2A8 + 0x40*x4 = 0x3B3A8，地址0x3B3A8中存储的值是符号表中的索引，<br />
为0xb32。由于machoviewer看不到符号表，所以用代码查看符号表中索引为0xB32 的符号信息。</p>
<p>查看代码：<code>struct nlist_64 const * mallocNlist =[self getSymbol64ByIndex:0xB32];</code></p>
<p><img src="media/17001892554959/17001910800200.jpg" alt="" /></p>
<p>图7 .代码查看符号表示意图。符号表的索引为0xB32的符号的信息。可以看出n_strx的值是0x2B07，<br />
这个值指的是string表中的偏移量</p>
<p><img src="media/17001892554959/17001910800256.jpg" alt="" /></p>
<p>图8 .string 表，string表的起始地址是0x3B498</p>
<p><img src="media/17001892554959/17001910800333.jpg" alt="" /></p>
<p>图9 .string 表， 偏移0x2B07 后的结果—— 0x3B498 + 0x2B07 = 0x3DF9F， 这个地址存储的字符串就是图3中</p>
<p>地址为0x10001ef10的函数指针的名称，名称是malloc。这个名称和我么要替换的名称一致，所以替换图3中的<br />
0x10001ef10，替换成新指定函数指针地址。实现替换。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/01/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001197697594.html">
                
                  <h1>解决Mac下Cornerstone无法查看SVN日志的问题</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<pre><code class="language-plain_text">Could not contact repository to read the latest log entries.The log displayed may be incomplete.
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="17001197697594.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2018/12/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='CS.html'>CS</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892555678.html">
                
                  <h1>UIButton扩大点击范围以及关于响应者链条的思考</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>平时开发遇到一个比较蛋疼的情景就是，设计给的按钮是40x40pt的，但是UE又觉得按钮太小，总是点不准，想要增大点击范围，这个要求合理合法，开发没有任何拒绝的理由。那就把按钮弄大吧，然后各种计算frame，按钮可能还有边框渐变色什么的，还得更复杂的处理一番，折腾下来身心俱疲。</p>
<p>程序员这么懒的人怎么可能做这种又low又类的工作呢，所以肯定是有解决方法的，一顿搜索后，发现智慧就是这么简单，想要扩大<code>UIButton</code>的响应区域，让用户在点击<code>UIButton</code>以外的范围的时候也可以响应按钮的触发事件，只需要重写<code>UIButton</code>的对象方法<code>-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</code>，然后只要点击在在想要响应按钮事件的范围内，返回YES即可。下面提供一个分类方法，直接设置hitEdgeInsets属性即可实现扩大响应范围。</p>
<pre><code class="language-swift">#import &lt;UIKit/UIKit.h&gt;
@interface UIButton (HitRect)

/**
自定义响应边界 UIEdgeInsetsMake(-3, -4, -5, -6). 表示扩大
例如： self.btn.hitEdgeInsets = UIEdgeInsetsMake(-3, -4, -5, -6);
*/
@property(nonatomic, assign) UIEdgeInsets hitEdgeInsets;

@end
</code></pre>
<pre><code class="language-swift">#import &quot;UIButton+HitRect.h&quot;

#import &lt;objc/runtime.h&gt;

@implementation UIButton (HitRect)
#pragma mark - set Method
- (void)setHitEdgeInsets:(UIEdgeInsets)hitEdgeInsets {
    NSValue *value = [NSValue value:&amp;hitEdgeInsets withObjCType:@encode(UIEdgeInsets)];
    objc_setAssociatedObject(self,kHitEdgeInsets, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

#pragma mark - get Method
- (UIEdgeInsets)hitEdgeInsets {
    NSValue *value = objc_getAssociatedObject(self, kHitEdgeInsets);
    UIEdgeInsets edgeInsets;
    [value getValue:&amp;edgeInsets];
    return value ? edgeInsets:UIEdgeInsetsZero;
}

#pragma mark - override super method
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    //如果 button 边界值无变化  失效 隐藏 或者透明 直接返回
    if (UIEdgeInsetsEqualToEdgeInsets(self.hitEdgeInsets, UIEdgeInsetsZero) || !self.enabled || self.hidden || self.alpha == 0 ) {
        return [super pointInside:point withEvent:event];
    } else {
        CGRect relativeFrame = self.bounds;
        CGRect hitFrame = UIEdgeInsetsInsetRect(relativeFrame, self.hitEdgeInsets);
        return CGRectContainsPoint(hitFrame, point);
    }
}
@end
</code></pre>
<h2><a id="%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>响应事件流程分析</h2>
<h3><a id="%E4%B8%80%E4%B8%AAuibutton%E4%B8%8A%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%B8%AAuiview%EF%BC%8C%E7%82%B9%E5%87%BBuiview%E7%9A%84%E6%97%B6%E5%80%99%E8%83%BD%E5%93%8D%E5%BA%94uibutton%E7%9A%84%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一个UIButton上加上一个UIView，点击UIView的时候能响应UIButton的响应事件吗？</h3>
<p>这个是有前提条件的，UIView有一个属性<code>userInteractionEnabled</code>，其他的继承UIView的控件也有这个属性，这个属性的意思就是当前视图是否支持交互，默认UIView的<code>userInteractionEnabled</code>是YES，所以是可交互的，当挡住UIButton的时候，UIView就不响应事件了。相对应的，UIImageView和UILabel默认是NO，所以如果不改这个属性的话，这两个控件是挡不住UIButton的。</p>
<h3><a id="%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8uiimageview%E4%B8%8A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAuibutton%EF%BC%8C%E7%82%B9%E5%87%BBuibutton%E7%9A%84%E6%97%B6%E5%80%99%E8%83%BD%E5%93%8D%E5%BA%94uibutton%E7%9A%84%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>还有一个引申的问题，如果在UIImageView上添加一个UIButton，点击UIButton的时候能响应UIButton的响应事件吗？</h3>
<p>默认情况下，UIButton是不能响应事件了，因为UIImageView的<code>userInteractionEnabled</code>默认是NO，是不支持交互的，这样的话，它上面的子View，也无法交互了。</p>
<p>一个小小的属性居然如此神奇，到底是何原因呢，这里就要说一下iOS的事件响应流程和响应者链条了。</p>
<h2><a id="why" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>WHY</h2>
<p>其实开始在这里还东鳞西爪了一些东西，始终觉得不够完善，调理也不够清晰，所以直接全删了，发现一些文章质量很高，先贴过来了，当然其中的很多猜想也不全是对的，所以看文章要小心咯。。</p>
<p><a href="https://www.jianshu.com/p/ef33cc31a614">https://www.jianshu.com/p/ef33cc31a614</a></p>
<p><a href="https://www.tuicool.com/articles/6VFn2q">https://www.tuicool.com/articles/6VFn2q</a></p>
<p><a href="http://www.cnblogs.com/Quains/p/3369132.html">http://www.cnblogs.com/Quains/p/3369132.html</a></p>
<p><a href="https://www.jianshu.com/p/8dca02b4687e">https://www.jianshu.com/p/8dca02b4687e</a></p>
<p><a href="https://yq.aliyun.com/articles/31481">https://yq.aliyun.com/articles/31481</a></p>
<p><a href="http://shellhue.github.io/2017/03/04/FlowOfUITouch/">http://shellhue.github.io/2017/03/04/FlowOfUITouch/</a></p>
<p><a href="http://www.cocoachina.com/ios/20160630/16868.html">http://www.cocoachina.com/ios/20160630/16868.html</a></p>
<p><a href="http://shellhue.github.io/2017/03/04/FlowOfUITouch/sw">http://shellhue.github.io/2017/03/04/FlowOfUITouch/sw</a></p>
<h2><a id="%E5%BC%BA%E8%BF%AB%E7%97%87%E7%8A%AF%E4%BA%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>强迫症犯了</h2>
<p>看完上面的文章我总觉得得写点什么补充补充，又不想写太多，就摘一些关键的地方吧。</p>
<h3><a id="%E6%B6%88%E6%81%AF%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息响应流程</h3>
<p>界面响应消息机制分两块，（1）首先在视图的层次结构里找到能响应消息的那个视图。（2）然后在找到的视图里处理消息。</p>
<p>【关键】（1）的过程是从父View到子View查找，而（2）是从找到的那个子View往父View回溯（不一定会往回传递消息）。</p>
<p><img src="media/17001892555678/17001899131882.png" alt="" /></p>
<h3><a id="%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实际开发遇到的问题</h3>
<p>在实际开发中，经常会遇到视图没有响应的情况，特别是新手会经常搞不清楚状况。</p>
<p>一下是视图没有响应的几个情况：</p>
<p>1.userInteractionEnabled=NO；</p>
<p>2.hidden=YES；</p>
<p>3.alpha=0~0.01；</p>
<p>4.没有实现touchesBegan:withEvent:方法，直接执行touchesMove:withEvent:等方法；</p>
<p>5.目标视图点击区域不在父视图的Frame上 (superView背景色为clear Color的时候经常会忽略这个问题)。</p>
<p>iOS响应者链的全过程:</p>
<p><img src="media/17001892555678/17001899131890.png" alt="" /></p>
<h2><a id="%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AAview%E6%89%80%E5%9C%A8%E7%9A%84viewcontroller" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>找到一个View所在的ViewController</h2>
<p>找到一个<code>view</code>所在的<code>controller</code>，其实就是顺着他的响应链一直往下找，直到找到一个<code>responser</code>类型是<code>UIViewController</code>。</p>
<pre><code class="language-swift">- (UIViewController*)findViewControllerOfView:(UIView*)view {

    id responser = view.nextResponder;

    UIViewController* resultController = [[UIViewController alloc] init];

    while (![responser isKindOfClass:[UIViewController class]]) {

        responser = [responser nextResponder];

    }

    if ([responser isKindOfClass:[UIViewController class]]) {

        resultController = responser;

    }

    return resultController;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UI.html'>UI</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892555599.html">
                
                  <h1>UILabel中文带行间距的处理，限制行数，计算高度等</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>最近设计同学终于受不了商品评价列表中的评价内容没有行间距，强迫我们必须加上行间距。</p>
<p>当时我就感觉一阵头大，因为这个评价内容如果超过五行的话，是默认不显示的，当用户点击展开才会显示，这样的话我就要在计算行数的时候把行间距算进去，还有一行的时候如果是中文是不能给Label加行间距的，否则一行文字下面会片空白，当然高度的计算也要去掉行间距。下面就详细讲一下如果解决这些问题。</p>
<h3><a id="%E9%80%9A%E8%BF%87boundingwithrect%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E7%9A%84%E9%AB%98%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通过boundingWithRect获取文本的高度</h3>
<pre><code class="language-swift">NSString *text = @&quot;UILabel中文带行间距的处理，限制行数，计算高度等&quot;; 
NSMutableAttributedString *attributeString = [[NSMutableAttributedString alloc] initWithString:text]; 
NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init]; 
style.lineSpacing = 10;  
[attributeString addAttribute:NSParagraphStyleAttributeName
                        value:style
                        range:NSMakeRange(0, text.length)]; 
[attributeString addAttribute:NSFontAttributeName 
                        value:[UIFont systemFontOfSize:14]
                        range:NSMakeRange(0, text.length)];
NSStringDrawingOptions options = NSStringDrawingUsesLineFragmentOrigin |
                                 NSStringDrawingUsesFontLeading;  
CGRect rect = [attributeString boundingRectWithSize:CGSizeMake(100, MAXFLOAT)
                                            options:options 
                                            context:nil];
</code></pre>
<h3><a id="%E4%B8%AD%E6%96%87%E5%AF%8C%E6%96%87%E6%9C%AC%E6%9C%89%E8%A1%8C%E9%97%B4%E8%B7%9D%E7%9A%84%E5%9D%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>中文富文本有行间距的坑</h3>
<ol>
<li>计算文字高度的坑：上面计算方式在计算带有中文，并且有行间距的富文本时，会出现在计算一行时，文本高度不对，多了一个行间距的高度。但在计算纯英文时却不会存在这个情况。这样会导致在存在父控件时，父控件整体高度计算不对。</li>
<li>给Label设置文本的坑：在给Label设置富文本时，如果是一行并且带中文，并且设置了间距lineSpace，结果多发现显示出来多了一个间距的高度。</li>
</ol>
<h3><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案</h3>
<ol>
<li>判断行数与是否存在中文，当行数为一行，并且存在中文时，需要将计算结果的高度减去行间距。此时才为正确文本正确高度。</li>
<li>需要判断是否超过一行，超过一行则设置富文本的lineSpace。</li>
</ol>
<p>下面是封装好的方法，可以直接给NSString创建一个category，把以下方法拷贝进去。</p>
<pre><code class="language-swift">/**
 * 计算文字高度，可以处理计算带行间距的
 */
- (CGSize)boundingRectWithSize:(CGSize)size
                          font:(UIFont*)font  
                   lineSpacing:(CGFloat)lineSpacing
{
    NSMutableAttributedString *attributeString = [[NSMutableAttributedString alloc] initWithString:self];
    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
    paragraphStyle.lineSpacing = lineSpacing;
    [attributeString addAttribute:NSParagraphStyleAttributeName
                            value:paragraphStyle
                            range:NSMakeRange(0, self.length)];
    [attributeString addAttribute:NSFontAttributeName
                            value:font 
                            range:NSMakeRange(0, self.length)];
    NSStringDrawingOptions options = NSStringDrawingUsesLineFragmentOrigin |         
                                     NSStringDrawingUsesFontLeading;
    CGRect rect = [attributeString boundingRectWithSize:size 
                                                options:options
                                                context:nil];

    //文本的高度减去字体高度小于等于行间距，判断为当前只有1行
    if ((rect.size.height - font.lineHeight) &lt;= paragraphStyle.lineSpacing)
    {
        if ([self containChinese:self]) 
        {  //如果包含中文
            rect = CGRectMake(rect.origin.x, 
                              rect.origin.y, 
                              rect.size.width, 
                              rect.size.height-paragraphStyle.lineSpacing);
        }
    }
    
    return rect.size;
}


//判断如果包含中文
- (BOOL)containChinese:(NSString *)str
{
    for(int i=0; i&lt; [str length];i++)
    {
        int a = [str characterAtIndex:i];
        if(a &gt; 0x4e00 &amp;&amp; a &lt; 0x9fff)
        { 
            return YES; 
        }
    }
    return NO;
}

/**
 *  计算最大行数文字高度,可以处理计算带行间距的
 */
- (CGFloat)boundingRectWithSize:(CGSize)size 
                           font:(UIFont*)font
                    lineSpacing:(CGFloat)lineSpacing
                       maxLines:(NSInteger)maxLines
{

    if (maxLines &lt;= 0)
    {
        return 0;
    }

    CGFloat maxHeight = font.lineHeight * maxLines + lineSpacing * (maxLines - 1);

    CGSize orginalSize = [self boundingRectWithSize:size
                                               font:font 
                                        lineSpacing:lineSpacing];

    if (orginalSize.height &gt;= maxHeight) 
    {
        return maxHeight;
    }
    else
    {
        return orginalSize.height;
    }
}

/**
 *  计算是否超过一行   用于给Label 赋值attribute text的时候 超过一行设置lineSpace
 */
- (BOOL)isMoreThanOneLineWithSize:(CGSize)size 
                             font:(UIFont *)font
                     lineSpaceing:(CGFloat)lineSpacing
{

    if ([self boundingRectWithSize:size
                              font:font
                       lineSpacing:lineSpacing].height &gt; font.lineHeight) 
    {
        return YES;
    }
    else
    {
       return NO;
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UI.html'>UI</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892555201.html">
                
                  <h1>UITableview调用reload方法时抖动问题</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>由于UITableview在iOS11的时候加入了Self-Sizing新特性，而且cell、header、footer是默认开启的，导致estimated的高度值变成了UITableViewAutomaticDimension（之前是0）。</p>
<p>如果不曾设置过estimateRowHeight属性的话，reload的时候可能会有一些奇怪的上下抖动，UITableview的位置也有可能不再停留在原来的位置。</p>
<p>解决方案就是给这些预估值赋值为0来禁用：</p>
<pre><code class="language-swift">if (@available(iOS 11.0, *)) {
    UITableView.appearance.estimatedRowHeight = 0;
    UITableView.appearance.estimatedSectionFooterHeight = 0;
    UITableView.appearance.estimatedSectionHeaderHeight = 0;
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UI.html'>UI</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001191228771.html">
                
                  <h1>C语言指针小结</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="17001191228771.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2018/11/07</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C/C++.html'>C/C++</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001189934109.html">
                
                  <h1>C语言数据类型和const、static关键字</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="17001189934109.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2018/11/07</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C/C++.html'>C/C++</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892555367.html">
                
                  <h1>iOS 截取整个 scrollview 图片</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>最近做的项目需要“分享图片”的功能，截屏不单单指当前屏幕可视区域，而是指整个 scrollView 区域，因为截屏的范围可自定义，所以只需要将 scrollview 的范围设置就可以，以下是相关代码：</p>
<pre><code class="language-swift">///获取截屏图片
- (UIImage *)captureScrollView:(UIScrollView *)scrollView
{
    UIImage* image = nil;
    UIGraphicsBeginImageContextWithOptions(scrollView.contentSize, NO, 0.0); // 原图清晰度
    {
        CGPoint savedContentOffset = scrollView.contentOffset;
        CGRect savedFrame = scrollView.frame;
        scrollView.contentOffset = CGPointZero;
        scrollView.frame = CGRectMake(0, 0, scrollView.contentSize.width, scrollView.contentSize.height);
        
        [scrollView.layer renderInContext: UIGraphicsGetCurrentContext()];
        image = UIGraphicsGetImageFromCurrentImageContext();
        
        scrollView.contentOffset = savedContentOffset;
        scrollView.frame = savedFrame;
    }
    UIGraphicsEndImageContext();
    
    if (image != nil) {
        return image;
    }
    return nil;
}
</code></pre>
<p>以上就是相关截整个 scrollview 屏幕方法。</p>
<p>注：可以通过修改 UIGraphicsBeginImageContextWithOptions 的参数值改变截图的大小。</p>
<p>如果想要截图清晰，可以用</p>
<pre><code class="language-swift">UIKIT_EXTERN void UIGraphicsBeginImageContextWithOptions(CGSize size, BOOL opaque, CGFloat scale) NS_AVAILABLE_IOS(4_0);
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/11/07</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UI.html'>UI</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892555950.html">
                
                  <h1>Objc源码分析-runtime-Class</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>看了一段时间<a href="https://opensource.apple.com/source/objc4/objc4-723/">objc</a>的源码，准备开个大坑，写一下了解到的东西，这一时半会是完工不了了，一篇一篇慢慢写吧。</p>
<p>先看一下官方对objc的介绍。</p>
<p>Objective-C is the primary programming language you use when writing software for OS X and iOS. It’s a superset of the C programming language and provides object-oriented capabilities and a dynamic runtime. Objective-C inherits the syntax, primitive types, and flow control statements of C and adds syntax for defining classes and methods. It also adds language-level support for object graph management and object literals while providing dynamic typing and binding, deferring many responsibilities until runtime.</p>
<p>（Objective-C是您在为OS X和iOS编写软件时使用的主要编程语言。 它是C编程语言的超集，提供面向对象的功能和动态运行时。 Objective-C继承了C的语法，原始类型和流控制语句，并添加了用于定义类和方法的语法。 它还为对象图管理和对象文字添加语言级支持，同时提供动态类型和绑定，将许多职责推迟到运行时。）</p>
<p>显然运行时是objc的这个语言非常重要的特性，它可以把很多静态语言（显然objc是动态语言）在编译和链接时期做的事情推迟到运行时期在做。这样写代码就有很大的灵活性，比如把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>所以说objc除了编译器之外，还需要一个运行时系统 (runtime system) 来执行编译后的代码。Objective-C Runtime 就是这个运行时系统了，这个库使得C有了面向对象的能力。</p>
<p>下面我们就分析一下runtime是如何做到的。</p>
<p>由于日常接触的最多的是类与对象，所以我准备就从这里开始写起。</p>
<h2><a id="class" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class</h2>
<p>OC的对象都是需要继承NSObject的，那么我们先看看NSObject。</p>
<pre><code class="language-swift">@interface NSObject &lt;NSObject&gt; {
    Class isa  OBJC_ISA_AVAILABILITY;
    // 这个 isa 其实没啥用，已经被废弃了， isa 存在 objc_object 中，并且是 isa_t 结构体类型的
    // 即使写 anObject-&gt;isa
    // Xcode 也报错：Direct accesss to Objective-C's isa deprecated in favor of object_getClass()
    // 建议我们用 object_getClass(), 它会返回 isa_t 中存的 Class cls
    // 如果这段注释看不懂可以跳过，最后回顾时自然会明白。
}
...
@end
</code></pre>
<p>发现除了常用了一些objc的方法外，有个Class类的isa指针。Class类在平时使用的时候会多多少少遇到过，比如说判断某对象是不是某类的实例。</p>
<pre><code class="language-swift">[foobar isMemberOfClass:[SomeClass class]]
</code></pre>
<p>通过看源码我们可以看到其实现。</p>
<pre><code class="language-swift">- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}

// isMemberOfClass 中 [self class]调用的是- (Class)class方法 
- (Class)class {
    return object_getClass(self);
}

// isMemberOfClass 中 [SomeClass class]调用的是+ (Class)class方法 
+ (Class)class {
    return self;
}
</code></pre>
<p>由以上代码可以看出，其实判断OC对象的类型，就是判断类型为Class的对象是否相等，那么Class到底是什么呢。</p>
<pre><code class="language-swift">typedef struct objc_class *Class;
</code></pre>
<p>可以看到Class其实就是指向objc_class结构体的指针（又被称为类对象）。</p>
<p>objc_class结构体里主要的成员如下。</p>
<pre><code class="language-swift">struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
    
    // 省略以下成员
}
</code></pre>
<p>现在我们可以说isMemberOfClass方法其实就是判断两个结构体（objc_class）实例的指针地址是否相同。</p>
<p>objc_class 又继承于objc_object，那么我们再看看objc_object的主要结构。</p>
<pre><code class="language-swift">struct objc_object {
private:
    isa_t isa;

public:

    // ISA() assumes this is NOT a tagged pointer object
    Class ISA();

    // getIsa() allows this to be a tagged pointer object
    Class getIsa();
    
    // 再次省略一下成员
}
</code></pre>
<p>看objc_object的名字也可以猜到这个应该和NSObject有关系，那么他们是怎么产生联系的呢？</p>
<p>在 <code>clang -rewrite-objc</code> （把oc代码转写成c/c++代码）后有这么一段：</p>
<pre><code class="language-swift">#ifndef _REWRITER_typedef_NSObject

#define _REWRITER_typedef_NSObject

typedef struct objc_object NSObject;

typedef struct {} _objc_exc_NSObject;

#endif
</code></pre>
<p>这下清楚了。。其实NSObject就是objc_object，一个OC对象其实就是objc_object或继承于objc_object的结构体的指针。。</p>
<p>objc_object结构体中也有一个isa_t类型的isa的成员，这个isa其实才是大家平时经常说的isa，之前在NSObject中的那个，其实是无效的，就是让大家看一下，如同runtime.h中的objc_class结构体定义一样，其实都已经失效了，真正的实现都被隐藏掉了，不过思路是正确的，依旧可以参考。</p>
<p>好，继续看isa_t是哪路神仙。</p>
<pre><code class="language-swift">union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    // 以下两个数据成员，同一时间只能储存一个
    // 也就是说如果或者是cls或者是bits
    // 这样可以达到节省内存的目的
    Class cls;
    uintptr_t bits;
    
    /// 再再次省略下面的代码，下面代码要展开谈的话，篇幅太大，等下次单开一篇详谈。
}
</code></pre>
<p>原来isa_t是个union，对union不了解的同学可以看<a href="http://www.anyanf.com/2018/union-in-c/">这篇文章</a>，大概意思可以看上面那段代码的注释。</p>
<p>其中cls就不用多解释了吧，bits不仅仅保存了指针，并对此做了优化，其中还包含了引用计数，析构状态，被其他 weak 变量引用情况，将来一一细表。</p>
<p>到此从整体上浏览了一下Class的结构，其中发现了一个很有意思的现象：</p>
<p>objc_object里有isa_t结构体类型的isa，这个isa包含当前objc_object的类的信息，其中有objc_class的指针，然后</p>
<p>objc_class又继承于objc_object，所以里面又有isa。。绕来绕去有点让人懵逼。别怕，让我们细细的捋一捋，结合后面那张图品味，味道更佳。</p>
<p>前面说过了，OC中的类其实就是一个指向objc_class结构体的指针（Class Object类对象），为了把OC中的类和对象区分开来，引入了一个叫做元类的概念（Meta Class），类对象的isa成员（也就是类对象的类）就是元类。它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似 <code>[NSObject alloc]</code> 的消息时，你事实上是把这个消息发给了一个类对象，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code> 会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p>
<p><img src="media/17001892555950/17001912055438.jpg" alt="" /></p>
<p>关于Class的简单介绍就到此为止了，其实简单来说还是我上面说了好几次的，OC的实例对象就是一个指向objc_object的指针，objc_object中有一个isa_t的成员isa，isa包含当前对象指向的类的信息，OC中的类是一个objc_class的结构体，该结构体继承于objc_object，所以OC中的类也是一个对象，类对象中的<code>isa_t</code>结构体包含了类对象指向的元类(meta-class，元类也是objc_class类型)的信息。</p>
<p>如同绕口令一般。</p>
<h2><a id="oc%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OC对象</h2>
<p>我们先定义一个类。</p>
<pre><code class="language-swift">@interface FoobarClass : NSObject {
    
    NSString *foobarStr;
    int foobarInt;

}
</code></pre>
<p>还是通过 <code>clang -rewrite-objc</code> （把oc代码转写成c/c++代码）转之后，代码如下。</p>
<pre><code class="language-swift">#ifndef _REWRITER_typedef_NSObject
#define _REWRITER_typedef_NSObject
typedef struct objc_object NSObject;
typedef struct {} _objc_exc_NSObject;
#endif

struct NSObject_IMPL {
	Class isa;
};


#ifndef _REWRITER_typedef_FoobarClass
#define _REWRITER_typedef_FoobarClass
typedef struct objc_object FoobarClass;
typedef struct {} _objc_exc_FoobarClass;
#endif

struct FoobarClass_IMPL {
	struct NSObject_IMPL NSObject_IVARS; // 通过这样的方式达到继承的目的
	NSString *foobarStr;
	int foobarInt;
};
</code></pre>
<p>通过以上代码可以看出FoobarClass类实例化的对象在内存中的是什么样子。</p>
<pre><code class="language-swift">Class isa;
NSString *foobarStr;
int foobarInt;
</code></pre>
<p>之前说过OC的对象是指向结构体实例的指针，所以有两个结论：</p>
<ol>
<li>成员isa的地址就是对象的首地址的值。</li>
<li>其他成员变量的地址就是对象的首地址地址加上相应的偏移量。</li>
</ol>
<p>请看下面例子。</p>
<pre><code class="language-swift">@implementation FoobarClass

- (instancetype)init
{
    self = [super init];
    if (self) {
        
        foobarStr = @&quot;hehe&quot;;
        
        NSLog(@&quot;foobarStr address : %p&quot;, &amp;foobarStr);

        foobarInt = 10;
        
        NSLog(@&quot;foobarInt address : %p&quot;, &amp;foobarInt);

        
    }
    return self;
}

@end

// 实例化一个对象
FoobarClass *foobar =  [FoobarClass new];
NSLog(@&quot;foobar address : %p&quot;, foobar);

// 打印结果
foobarStr address : 0x10064cc68
foobarInt address : 0x10064cc70
foobar address : 0x10064cc60

</code></pre>
<p><img src="media/17001892555950/17001912055451.png" alt="" /></p>
<p>在之前已经介绍过类对象和元类，以及他们的关系，在这里需要强调一下的是，一个OC对象的对象（-）方法，是在类对象里保存的；而类（+）方法，是在元类里保存的。</p>
<p><img src="media/17001892555950/17001912055459.png" alt="" /></p>
<p>通过这个巧妙的设计，可以很方面的区分对象方法和类方法，使得OC中的对象和类达到了结构上的统一。方法的调用的逻辑看着也非常简约：</p>
<ol>
<li>对象方法调用时，通过OC对象的isa在类中查找方法的实现。</li>
<li>类方法调用时，通过类对象的isa（OC对象的isa的isa）在元类中获取方法的实现。（OC对象的类方法，就是元类中的对象方法）</li>
</ol>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>为了有个整体的理解，开篇全讲类和对象了，很多东西都是浅尝辄止，后面会进行深入的探讨，一一补全。</p>
<h2><a id="%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考</h2>
<ol>
<li>
<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/ObjCRuntimeRef/">Objective-C Runtime Reference</a></p>
</li>
<li>
<p><a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/">Objective-C Runtime 运行时之一：类与对象</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/e3445ad41dbf">Objective-C对象解析</a></p>
</li>
<li>
<p><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a></p>
</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/10/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OC.html'>OC</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="CS_3.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="CS_5.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>DreamEverAfter</h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Pages.html"><strong>Pages</strong></a>
        
            <a href="CS.html"><strong>CS</strong></a>
        
            <a href="List.html"><strong>List</strong></a>
        
            <a href="%E6%9D%82.html"><strong>杂</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="17005448149061.html">贴牌品牌</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16996865532784.html">三汁焖锅</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001172774052.html">别了，中国大陆的Kindle</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001265068678.html">HomeBrew更新报错“fatal- Could not resolve HEAD to a revision”</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001892553950.html">SwiftUI基本控件</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
