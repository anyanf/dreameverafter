<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  CMake入门及常用变量指令手册 - DreamEverAfter
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="DreamEverAfter" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.dreameverafter.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="tools.html">工具</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; DreamEverAfter</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="tools.html">工具</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Pages.html">Pages</a></li>
        
            <li><a href="CS.html">CS</a></li>
        
            <li><a href="List.html">List</a></li>
        
            <li><a href="%E6%9D%82.html">杂</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>CMake入门及常用变量指令手册</h1>
     
        <div class="read-more clearfix">
          <span class="date">2019/09/21</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='CS.html'>CS</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <h2><a id="%E5%AE%9E%E6%88%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实战</h2>
<p>参考《CMake Practice》。</p>
<span id="more"></span><!-- more -->
<h3><a id="%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目目录结构</h3>
<p>我们项目的名称为CRNode，假设我们项目的所有文件存放再~/workspace/CRNode，之后没有特殊说明的话，我们所指的目录都以此目录为相对路径。<br />
我们的目录结构如下：</p>
<pre><code class="language-plain_text">~/workspace/CRNode
  ├─ src
  │  ├─ rpc
  │  │  ├─ CRMasterCaller.h
  │  │  ├─ CRMasterCaller.cc
  │  │  ├─ CRNode.h
  │  │  ├─ CRNode.cc
  │  │  ├─ Schd_constants.h
  │  │  ├─ Schd_constants.cc
  │  │  ├─ CRMaster.h
  │  │  ├─ CRMaster.cc
  │  │  ├─ CRNode_server.skeleton.h
  │  │  ├─ CRNode_server.skeleton.cc
  │  │  ├─ Schd_types.h
  │  │  └─ Schd_types.cc
  │  ├─ task
  │  │  ├─ TaskExecutor.h
  │  │  ├─ TaskExecutor.cc
  │  │  ├─ TaskMonitor.h
  │  │  └─ TaskMonitor.cc
  │  ├─ util
  │  │  ├─ Const.h
  │  │  ├─ Const.cc
  │  │  ├─ Globals.h
  │  │  ├─ Globals.cc
  │  │  ├─ Properties.h
  │  │  ├─ Properties.cc
  │  │  ├─ utils.h
  │  │  └─ utils.cc
  │  ├─ main.cc
  │  └─ CMakeLists.txt
  ├─ doc
  │  └─ crnode.txt
  ├─ COPYRIGHT
  ├─ README
  ├─ crnode.sh
  └─ CMakeLists.txt
</code></pre>
<p>其中，src存放源代码文件和一个CMakeLists.txt文件，CMakeLists文件的编写我们稍候介绍；doc目录中存放项目的帮助文档，该文档以及COPYRIGHT和README一起安装到/usr/share/doc/crnode目录中；COPYRIGHT文件存放项目的版权信息，README存放一些说明性文字；crnode.sh存放CRNode的启动命令；CMakeLists.txt文件稍候介绍。</p>
<p>除此之外，项目还依赖两个外部库：Facebook开发的thrift库，其头文件存放在/usr/include/thrift目录中；log4cpp库，其头文件存放再/usr/include下。</p>
<h3><a id="cmakelists-txt%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMakeLists.txt文件</h3>
<p>本工程中使用了两个CMakeLists.txt文件，分别项目的根目录（即~/workspace/CRNode目录，下同）和src目录中（参考以上目录结构）。我们先给出两个CMakeLists.txt的内容，在下一节中再对两个CMakeLists.txt进行详细介绍。两个CMakeLists.txt文件的内容分别如下：</p>
<h4><a id="%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%ADcmakelists%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>根目录中CMakeLists内容</h4>
<pre><code class="language-plain_text">cmake_minimum_required (VERSION 2.6)

project (CRNode)

ADD_SUBDIRECTORY(src bin)

# SET(CMAKE_INSTALL_PREFIX ${PROJECT_BINARY_DIR})
SET(CMAKE_INSTALL_PREFIX /usr/local)

INSTALL(PROGRAMS crnode.sh DESTINATION bin)

INSTALL(FILES COPYRIGHT README DESTINATION share/doc/crnode)

INSTALL(DIRECTORY doc/ DESTINATION share/doc/crnode)
</code></pre>
<h4><a id="srccmakelists-txt%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>src/CMakeLists.txt内容</h4>
<pre><code class="language-plain_text">INCLUDE_DIRECTORIES(/usr/include/thrift)

SET(SRC_LIST main.cc
        rpc/CRMasterCaller.cpp
        rpc/CRNode_server.skeleton.cpp
        rpc/Schd_constants.cpp
        rpc/CRMaster.cpp
        rpc/CRNode.cpp
        rpc/Schd_types.cpp
        task/TaskExecutor.cpp
        task/TaskMoniter.cpp
        util/Const.cpp
        util/Globals.cc
        util/utils.cc
        util/Properties.cpp
        )

ADD_EXECUTABLE(crnode ${SRC_LIST})

TARGET_LINK_LIBRARIES(crnode log4cpp thrift)

INSTALL(TARGETS crnode
        RUNTIME DESTINATION bin
)
</code></pre>
<h4><a id="cmake%E8%AF%AD%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMake语法</h4>
<ol>
<li>变量使用${}方式取值,但是在 IF 控制语句中是直接使用变量名；</li>
<li>指令(参数 1 参数 2…)，参数使用括弧括起,参数之间使用空格或分号分开；</li>
<li>指令是大小写无关的,参数和变量是大小写相关的。但,推荐你全部使用大写指令。</li>
</ol>
<h4><a id="cmakelists-txt%E5%89%96%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMakeLists.txt剖析</h4>
<h5><a id="cmake-minimum-required%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cmake_minimum_required命令</h5>
<pre><code class="language-plain_text">cmake_minimum_required (VERSION 2.6)
</code></pre>
<p>规定cmake程序的最低版本。这行命令是可选的，我们可以不写这句话，但在有些情况下，如果CMakeLists.txt文件中使用了一些高版本cmake特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行cmake。</p>
<h5><a id="project%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>project命令</h5>
<pre><code class="language-plain_text">project (CRNode)
</code></pre>
<p>指定项目的名称。项目最终编译生成的可执行文件并不一定是这个项目名称，而是由另一条命令确定的，稍候我们再介绍。</p>
<p>但是这个项目名称还是必要的，在cmake中有两个预定义变量：<code>&lt; projectname &gt;_BINARY_DIR</code>以及<code>&lt; projectname &gt;_SOURCE_DIR</code>，在我们的项目中，两个变量分别为：<code>CRNode_BINARY_DIR</code>和<code>CRNode_SOURCE_DIR</code>。内部编译情况下两者相同，后面我们会讲到外部编译,两者所指代的内容会有所不同。要理解这两个变量的定义，我们首先需要了解什么是“外部构建（out-of-source build）”，我们将在下一小节中介绍“外部构建”。</p>
<p>同时cmake还预定义了PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR变量。在我们的项目中，PROJECT_BINARY_DIR等同于CRNode_BINARY_DIR，PROJECT_SOURCE_DIR等同于CRNode_SOURCE_DIR。在实际的应用用，我强烈推荐使用PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR变量，这样即使项目名称发生变化也不会影响CMakeLists.txt文件。</p>
<h5><a id="%E5%A4%96%E9%83%A8%E6%9E%84%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>外部构建</h5>
<p>假设我们此时已经完成了两个CMakeLists.txt文件的编写，可以执行cmake命令生成Makefile文件了。此时我们由两种方法可以执行cmake、编译和安装：</p>
<pre><code class="language-plain_text">cmake .
make

# 或者

mkdir build
cd build
cmake ..
make
</code></pre>
<p>两种方法最大的不同在于执行cmake和make的工作路径不同。第一种方法中，cmake生成的所有中间文件和可执行文件都会存放在项目目录中；而第二种方法中，中间文件和可执行文件都将存放再build目录中。第二种方法的优点显而易见，它最大限度的保持了代码目录的整洁。同时由于第二种方法的生成、编译和安装是发生在不同于项目目录的其他目录中，所以第二种方法就叫做“外部构建”。</p>
<p>回到之前的疑问，再外部构建的情况下，PROJECT_SOURCE_DIR指向的目录同内部构建相同，仍然为~/workspace/CRNode，而PROJECT_BINARY_DIR则有所不同，指向~/workspace/CRNode/build目录。<br />
当然，cmake强烈推荐使用外部构建的方法。</p>
<h5><a id="add-subdirectory%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ADD_SUBDIRECTORY命令</h5>
<pre><code class="language-plain_text">ADD_SUBDIRECTORY(src bin)
</code></pre>
<p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])这个指令用于向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除。比如,工程的 example,可能就需要工程构建完成后,再进入 example 目录单独进行构建。</p>
<p>在我们的项目中，我们添加了src目录到项目中，而把对应于src目录生成的中间文件和目标文件存放到bin目录下，在上一节举例中“外部构建”的情况下，中间文件和目标文件将存放在build/srcobj目录下。</p>
<h5><a id="set%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SET命令</h5>
<pre><code class="language-plain_text">SET(CMAKE_INSTALL_PREFIX /usr/local)
</code></pre>
<p>现阶段,只需要了解SET命令可以用来显式的定义变量即可。在以上的例子中，我们显式的将CMAKE_INSTALL_PREFIX的值定义为/usr/local，如此在外部构建情况下执行make install命令时，make会将生成的可执行文件拷贝到/usr/local/bin目录下。</p>
<p>当然，可执行文件的安装路径CMAKE_INSTALL_PREFIX也可以在执行cmake命令的时候指定，cmake参数如下：</p>
<pre><code class="language-plain_text">cmake -DCMAKE_INSTALL_PREFIX=/usr ..
</code></pre>
<p>如果cmake参数和CMakeLists.txt文件中都不指定该值的话，则该值为默认的/usr/local。</p>
<h5><a id="include-directories%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>INCLUDE_DIRECTORIES命令</h5>
<pre><code class="language-plain_text">INCLUDE_DIRECTORIES(/usr/include/thrift)
</code></pre>
<p>INCLUDE_DIRECTORIES类似gcc中的编译参数“-I”，指定编译过程中编译器搜索头文件的路径。当项目需要的头文件不在系统默认的搜索路径时，需要指定该路径。在我们的项目中，log4cpp所需的头文件都存放在/usr/include下，不需要指定；但thrift的头文件没有存放在系统路径下，需要指定搜索其路径。</p>
<h5><a id="add-executable%E5%92%8Cadd-library" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ADD_EXECUTABLE和ADD_LIBRARY</h5>
<pre><code class="language-plain_text">SET(SRC_LIST main.cc
        rpc/CRMasterCaller.cpp
        rpc/CRNode_server.skeleton.cpp
        rpc/Schd_constants.cpp
        rpc/CRMaster.cpp
        rpc/CRNode.cpp
        rpc/Schd_types.cpp
        task/TaskExecutor.cpp
        task/TaskMoniter.cpp
        util/Const.cpp
        util/Globals.cc
        util/utils.cc
        util/Properties.cpp
        )

ADD_EXECUTABLE(CRNode ${SRC_LIST})
</code></pre>
<p>ADD_EXECUTABLE定义了这个工程会生成一个文件名为 CRNode 的可执行文件,相关的源文件是 SRC_LIST 中定义的源文件列表。需要注意的是，这里的CRNode和之前的项目名称没有任何关系，可以任意定义。</p>
<h5><a id="executable-output-path%E5%92%8Clibrary-output-path" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH</h5>
<p>我们可以通过 SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置(指最终生成的CRNode可执行文件或者最终的共享库，而不包含编译生成的中间文件)。</p>
<p>命令如下：</p>
<pre><code class="language-plain_text">SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
</code></pre>
<p>需要注意的是，在哪里 ADD_EXECUTABLE 或 ADD_LIBRARY，如果需要改变目标存放路径,就在哪里加入上述的定义。</p>
<h5><a id="target-link-libraries%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TARGET_LINK_LIBRARIES命令</h5>
<pre><code class="language-plain_text">TARGET_LINK_LIBRARIES(CRNode log4cpp thrift)
</code></pre>
<p>这句话指定在链接目标文件的时候需要链接的外部库，其效果类似gcc的编译参数“-l”，可以解决外部库的依赖问题。</p>
<h5><a id="install%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>INSTALL命令</h5>
<p>在执行INSTALL命令的时候需要注意CMAKE_INSTALL_PREFIX参数的值。其命令形式如下：</p>
<pre><code class="language-plain_text">install(TARGETS targets... [EXPORT &lt;export-name&gt;]
      [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
        PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
       [DESTINATION &lt;dir&gt;]
       [PERMISSIONS permissions...]
       [CONFIGURATIONS [Debug|Release|...]]
       [COMPONENT &lt;component&gt;]
       [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
      ] [...])
</code></pre>
<p>参数中的 TARGETS 后面跟的就是我们通过 ADD_EXECUTABLE 或者 ADD_LIBRARY 定义的目标文件,可能是可执行二进制、动态库、静态库。</p>
<p>DESTINATION 定义了安装的路径,如果路径以/开头,那么指的是绝对路径,这时候CMAKE_INSTALL_PREFIX 其实就无效了。如果你希望使用 CMAKE_INSTALL_PREFIX 来定义安装路径,就要写成相对路径,即不要以/开头,那么安装后的路径就是${CMAKE_INSTALL_PREFIX} /&lt; destination 定义的路径&gt; 。</p>
<p>你不需要关心 TARGETS 具体生成的路径,只需要写上 TARGETS 名称就可以了。</p>
<p>非目标文件的可执行程序安装(比如脚本之类):</p>
<pre><code class="language-plain_text">INSTALL(PROGRAMS files... DESTINATION &lt; dir &gt;
	[PERMISSIONS permissions...]
	[CONFIGURATIONS [Debug|Release|...]]
	[COMPONENT &lt; component &gt;]
	[RENAME &lt; name &gt;] [OPTIONAL])
</code></pre>
<p>跟上面的 FILES 指令使用方法一样,唯一的不同是安装后权限为OWNER_EXECUTE, GROUP_EXECUTE, 和 WORLD_EXECUTE,即 755 权限目录的安装。</p>
<p>安装一个目录的命令如下：</p>
<pre><code class="language-plain_text">INSTALL(DIRECTORY dirs... DESTINATION &lt; dir &gt;
	[FILE_PERMISSIONS permissions...]
	[DIRECTORY_PERMISSIONS permissions...]
	[USE_SOURCE_PERMISSIONS]
	[CONFIGURATIONS [Debug|Release|...]]
	[COMPONENT &lt; component &gt;]
	[[PATTERN &lt; pattern &gt; | REGEX &lt; regex &gt;]
	[EXCLUDE] [PERMISSIONS permissions...]] [...])
</code></pre>
<p>DIRECTORY 后面连接的是所在 Source 目录的相对路径,但务必注意:abc 和 abc/有很大的区别。如果目录名不以/结尾,那么这个目录将被安装为目标路径下的 abc,如果目录名以/结尾,代表将这个目录中的内容安装到目标路径,但不包括这个目录本身。我们来看一个例子:</p>
<pre><code class="language-plain_text">INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj
	PATTERN &quot;CVS&quot; EXCLUDE
	PATTERN &quot;scripts/*&quot;
	PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
	GROUP_EXECUTE GROUP_READ)
</code></pre>
<p>这条指令的执行结果是:</p>
<p>将 icons 目录安装到 &lt; prefix &gt;/share/myproj，将 scripts/中的内容安装到&lt; prefix &gt;/share/myproj，不包含目录名为 CVS 的目录,对于 scripts/*文件指定权限为 OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ。</p>
<p>因为crnode.txt 要安装到/&lt; prefix &gt;/share/doc/crnode,所以我们不能直接安装整个 doc 目录,这里采用的方式是安装 doc 目录中的内容,也就是使用”doc/”在工程文件中添加:</p>
<pre><code class="language-plain_text">INSTALL(DIRECTORY doc/ DESTINATION share/doc/crnode)
</code></pre>
<h4><a id="%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编译安装</h4>
<p>编译安装结果如下：</p>
<pre><code class="language-plain_text">[root@sim91 build]# cmake ..
-- Configuring done
-- Generating done
-- Build files have been written to: /home/fify/workspace/CRNode/build

[root@sim91 build]# make
Scanning dependencies of target crnode
[  7%] Building CXX object srcobj/CMakeFiles/crnode.dir/main.cc.o
[ 15%] Building CXX object srcobj/CMakeFiles/crnode.dir/rpc/CRMasterCaller.cpp.o
[ 23%] Building CXX object srcobj/CMakeFiles/crnode.dir/rpc/CRNode_server.skeleton.cpp.o
[ 30%] Building CXX object srcobj/CMakeFiles/crnode.dir/rpc/Schd_constants.cpp.o
[ 38%] Building CXX object srcobj/CMakeFiles/crnode.dir/rpc/CRMaster.cpp.o
[ 46%] Building CXX object srcobj/CMakeFiles/crnode.dir/rpc/CRNode.cpp.o
[ 53%] Building CXX object srcobj/CMakeFiles/crnode.dir/rpc/Schd_types.cpp.o
[ 61%] Building CXX object srcobj/CMakeFiles/crnode.dir/task/TaskExecutor.cpp.o
[ 69%] Building CXX object srcobj/CMakeFiles/crnode.dir/task/TaskMoniter.cpp.o
[ 76%] Building CXX object srcobj/CMakeFiles/crnode.dir/util/Const.cpp.o
[ 84%] Building CXX object srcobj/CMakeFiles/crnode.dir/util/Globals.cc.o
[ 92%] Building CXX object srcobj/CMakeFiles/crnode.dir/util/utils.cc.o
[100%] Building CXX object srcobj/CMakeFiles/crnode.dir/util/Properties.cpp.o
Linking CXX executable crnode

[root@sim91 build]# make install
[100%] Built target crnode
Install the project...
-- Install configuration: &quot;&quot;
-- Installing: /usr/local/bin/crnode.sh
-- Installing: /usr/local/share/doc/crnode/COPYRIGHT
-- Installing: /usr/local/share/doc/crnode/README
-- Installing: /usr/local/share/doc/crnode
-- Installing: /usr/local/share/doc/crnode/crnode.txt
-- Installing: /usr/local/bin/crnode
</code></pre>
<p>大功告成！更多内容请参考《CMake Practice》，再次对《CMake Practice》的作者表示感谢！</p>
<blockquote>
<p>这段引用自：<a href="https://www.cnblogs.com/ph829/p/4759124.html">https://www.cnblogs.com/ph829/p/4759124.html</a></p>
</blockquote>
<h2><a id="%E9%87%8D%E7%82%B9%E8%AF%B4%E4%B8%80%E4%B8%8Bconfigure-make-make-install%E7%9A%84%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重点说一下./configure,make,make install的作用</h2>
<p>这些都是典型的使用GNU的AUTOCONF和AUTOMAKE产生的程序的安装步骤。</p>
<p><code>./configure</code>是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个脚本。</p>
<p>make是用来编译的，它从Makefile中读取指令，然后编译。</p>
<p>make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p>
<p>AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。</p>
<h3><a id="configure" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>configure</h3>
<p>这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p>
<h3><a id="make" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>make</h3>
<p>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p>
<h3><a id="make-insatll" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>make insatll</h3>
<p>这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。如果用bin_PROGRAMS宏的话，程序会被安装至/usr/local/bin这个目录。或者库文件拷贝到相应的目录下。</p>
<p>该命令为一个工程生成安装规则。在某一源文件路径中，调用这条命令所指定的规则会在安装时按顺序执行。在不同路径之间的顺序未定义。</p>
<p>该命令有诸多版本。其中的一些版本定义了文件以及目标的安装属性。这多个版本的公共属性都有所涉及，但是只有在指定它们的版本中，这些属性才是合法的（下面的DESTIONATION到OPTIONAL的选项列表是公共属性。——译注）。</p>
<p>DESTINATION选项指定了一个文件会安装到磁盘的哪个路径下。若果给出的是全路径（以反斜杠或者驱动器名开头），它会被直接使用。如果给出的是相对路径，它会被解释为相对CMAKE_INSTALL_PREFIX的值的相对路径。</p>
<p>PERMISSIONS选项制定了安装文件需要的权限。合法的权限有：OWNER_READ，OWNER_WRITE，OWNER_EXECUTE，GROUP_READ，GROUP_WRITE，GROUP_EXECUTE，WORLD_READ，WORLD_WRITE，WORLD_EXECUTE，SETUID和SETGID。对于在某些特定的平台上没有意义的权限，在这些平台上会忽略这些选项。</p>
<p>CONFIGURATIONS选项指定了该安装规则将会加诸之上的一系列的构建配置（Debug，Release，等等）。</p>
<p>COMPONENT选项指定了该安装规则相关的一个安装部件的名字，比如“runtime”或“development”。对于那些指定安装部件的安装过程来说，在安装时只有与给定的部件名相关的安装规则会被执行。对于完整安装，所有部件都会被安装。</p>
<p>RENAME选项为一个可能不同于原始文件的已经安装的文件指定另一个名字。重命名只有在该命令正在安装一个单一文件时才被允许（猜测是为了防止文件名冲突时覆盖掉旧文件。——译注）。</p>
<p>OPTIONAL选项表示要安装的文件不存在不会导致错误。</p>
<h4><a id="targets%E7%89%88%E6%9C%AC%E7%9A%84install%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TARGETS版本的install命令</h4>
<pre><code class="language-plain_text">install(TARGETS targets... [EXPORT &lt;export-name&gt;]
      [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE|
        PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]
       [DESTINATION &lt;dir&gt;]
       [PERMISSIONS permissions...]
       [CONFIGURATIONS [Debug|Release|...]]
       [COMPONENT &lt;component&gt;]
       [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP]
      ] [...])
</code></pre>
<p>TARGETS格式的install命令规定了安装工程中的目标（targets）的规则。有5中可以被安装的目标文件：ARCHIVE，LIBRARY，RUNTIME，FRAMEWORK，和BUNDLE。除了被标记为MACOSX_BUNDLE属性的可执行文件被当做OS X上的BUNDLE目标外，其他的可执行文件都被当做RUNTIME目标。静态链接的库文件总是被当做ARCHIVE目标。模块库总是被当做LIBRARY目标。对于动态库不是DLL格式的平台来说，动态库会被当做LIBRARY目标来对待，被标记为FRAMEWORK的动态库是例外，它们被当做OS X上的FRAMEWORK目标。对于DLL平台而言，动态库的DLL部分被当做一个RUNTIME目标而对应的导出库被当做是一个ARCHIVE目标。所有基于Windows的系统，包括Cygwin，都是DLL平台。ARCHIVE，LIBRARY，RUNTIME和FRAMEWORK参数改变了后续属性会加诸之上的目标的类型。如果只给出了一种类型，那么只有那种类型的目标会被安装（这样通常只会安装一个DLL或者一个导出库。）</p>
<p>PRIVATE_HEADER，PUBLIC_HEADER，和RESOURCE选项的功能是，在非苹果平台上，将后续的属性应用在待安装的一个FRAMEWORK共享库目标的相关文件上。这些选项定义的规则在苹果系统上会被忽略掉，因为相关的文件将会被安装到framework文件夹内的合适位置。参见PRIVATE_HEADER，PUBLIC_HEADER和RESOURCE目标属性中更为详细的解释。</p>
<pre><code class="language-plain_text">可以指定NAMELINK_ONLY或者NAMELINK_SKIP选项作为LIBRARY选项。在一些平台上，版本化的共享库有一个符号链接，比如lib&lt;name&gt;.so -&gt; lib&lt;name&gt;.so.1，其中“lib&lt;name&gt;.so.1”是so库文件名（soname）而“lib&lt;name&gt;.so”是一个符号链接，当指定“-l&lt;name&gt;”选项时，链接器将会查找这个符号链接。如果一个库目标已经被安装，NAMELINK_ONLY选项表示仅仅安装符号链接；而NAME_SKIP选项则表示仅仅安装库文件而不是符号链接。当两种选项都没有给出时，动态库的两个部分都会被安装。在那些版本化的共享库没有符号链接或者库没有被版本化的平台，选项NAMELINK_SKIP安装这个库，而NAMELINK_ONLY选项什么都不会安装。参见VERSION和SOVERSION目标属性，获取关于创建版本化共享库的更多细节。
</code></pre>
<p>在该命令的TARGETS版本的一次调用中，可以一次性指定一个或多个属性组。一个目标也可以被多次安装到不同的位置。假设有三个目标myExe，mySharedLib和myStaticLib，下面的代码</p>
<pre><code class="language-plain_text">install(TARGETS myExe mySharedLib myStaticLib
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib/static)
install(TARGETS mySharedLib DESTINATION /some/full/path)
</code></pre>
<p>将会把myExe安装到<prefix>/bin目录下，把myStaticLib安装到<prefix>/lib/static目录下。在非-DLL平台上，mySharedLib将会被安装到<prefix>/lib和/some/full/path下。在DLL平台上，mySharedLib DLL将会被安装到<prefix>/bin和/some/full/path路径下，它的导出库会被安装到<prefix>/lib/static和/some/full/path路径下。</p>
<p>EXPORT选项将已经安装的目标文件和一个名为<export-name>的导出文件关联起来。它必须出现在所有RUNTIME，LIBRARY或者ARCHIVE选项之前。为了实际安装导出文件本身（export file），调用install(EXPORT)。参见下述install命令EXPORT版本的文档获取更多的细节。</p>
<p>将EXCLUDE_FROM_ALL设置为true时，安装一个目标会造成未定义的行为。</p>
<h4><a id="files%E7%89%88%E6%9C%AC%E7%9A%84install%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FILES版本的install命令</h4>
<pre><code class="language-plain_text">install(FILES files... DESTINATION &lt;dir&gt;
      [PERMISSIONS permissions...]
      [CONFIGURATIONS [Debug|Release|...]]
      [COMPONENT &lt;component&gt;]
      [RENAME &lt;name&gt;] [OPTIONAL])
</code></pre>
<p>FILES版本的install命令指定了为一个工程安装文件的规则。在命令中，以相对路径方式给出的文件名是相对于当前源代码路径而言的。以这个版本安装的文件，如果没有指定PERMISSIONS选项，默认会具有OWNER_WRITE，OWNER_READ，GROUP_READ，和WORLD_READ的权限。</p>
<h4><a id="programs%E7%89%88%E6%9C%AC%E7%9A%84install%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PROGRAMS版本的install命令</h4>
<pre><code class="language-plain_text">install(PROGRAMS files... DESTINATION &lt;dir&gt;
      [PERMISSIONS permissions...]
      [CONFIGURATIONS [Debug|Release|...]]
      [COMPONENT &lt;component&gt;]
      [RENAME &lt;name&gt;] [OPTIONAL])
</code></pre>
<p>PROGRAMS版本与FILES版本一样，只在默认权限上有所不同：它还包括了OWNER_EXECUTE，GROUP_EXECUTE和WORLD_EXECUTE选项。INSTALL的这个版本用来安装不是目标的程序，比如shell脚本。使用TARGETS格式安装该工程内部构建的目标。</p>
<h4><a id="directory%E7%89%88%E6%9C%AC%E7%9A%84install%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DIRECTORY版本的install命令</h4>
<pre><code class="language-plain_text">install(DIRECTORY dirs... DESTINATION &lt;dir&gt;
      [FILE_PERMISSIONS permissions...]
      [DIRECTORY_PERMISSIONS permissions...]
      [USE_SOURCE_PERMISSIONS] [OPTIONAL]
      [CONFIGURATIONS [Debug|Release|...]]
      [COMPONENT &lt;component&gt;] [FILES_MATCHING]
      [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]
       [EXCLUDE] [PERMISSIONS permissions...]] [...])
</code></pre>
<p>INSTALL的DIRECTORY版本将一个或者多个路径下的内容安装到指定的目标地址下。目录结构会原封不动地（verbatim）拷贝到目标地址。每个路径名的最后一部分会追加到目标路径下，但是结尾反斜杠（trailing slash）可以用来避免这一点，因为这样最后一部分就是空的。给定的相对路径名被解释成相对于当前源路径的路径。如果没有指定输入目录名字，目标目录会被创建，但是不会安装任何东西。FILE_PERMISSIONS和DIRECTORY_PERMISSIONS选项指定了赋予目标路径和目标文件的权限。如果指定了USE_SOURCE_PERMISSIONS选项，但没有指定FILE_PERMISSIONS选项，文件权限将沿袭源目录结构的权限，而且这个路径会被赋予PAROGRAMS版本中指定的默认权限。</p>
<p>通过使用PATTERN或REGEX选项可以对路径安装做出细粒度的控制。这些用于匹配的选项指定了一个查询模式或正则表达式来匹配输入路径内的路径或文件。它们可以用来将特定的选项（见下文）加诸于遇到的文件和路径的一个子集上。每个输入文件或路径的完整路径（反斜杠/开头的路径）将用来匹配该表达式。PATTERN仅仅用来匹配完全文件名：匹配该模式的全路径的那部分必须出现在文件名的结尾，并且必须以一个反斜杠开始。</p>
<p>正则表达式会用来匹配一个完全路径的任何部分，但是它也可以使用'/'和'$'模仿PATTERN的行为。默认情况下，所有文件和路径不管是否匹配都会被安装。可以在第一个匹配选项之前指定FILE_MATCHING选项，这样就能禁止安装那些不与任何表达式匹配的文件。比如，代码</p>
<pre><code class="language-plain_text">install(DIRECTORY src/ DESTINATION include/myproj
      FILES_MATCHING PATTERN &quot;*.h&quot;)
</code></pre>
<p>将会精确匹配并安装从源码树上得到的头文件。</p>
<p>有些选项后面可以跟在PATTERN或者REGEX表达式的后面，这样这些选项只能加诸于匹配PATTERN/REGEX的文件或路径上。EXCLUDE选项将会指示安装过程跳过那些匹配的文件或者路径。PERMISSIONS选项可以覆盖那些匹配PATTERN/REGEX的文件的权限设定。例如，代码</p>
<pre><code class="language-plain_text">install(DIRECTORY icons scripts/ DESTINATION share/myproj
      PATTERN &quot;CVS&quot; EXCLUDE
      PATTERN &quot;scripts/*&quot;
      PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                  GROUP_EXECUTE GROUP_READ)
</code></pre>
<p>会将icons路径安装到share/myproject/icons下，同时把scripts目录安装到share/myproj路径下。icons将具备默认的文件权限，scripts将会被给与指定的权限，但是所有CVS路径排除在外。</p>
<h4><a id="script%E5%92%8Ccode%E7%89%88%E6%9C%AC%E7%9A%84install%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SCRIPT和CODE版本的install命令</h4>
<pre><code class="language-plain_text">install([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]] [...])
</code></pre>
<p>SCRIPT格式将会在安装期调用给定的脚本文件。如果脚本文件名是一个相对路径，它会被解释为相对于当前的源路径。CODE格式将会在安装期调用给定的CMake代码。code被指定为一个双引号括起来的单独的参数。例如，代码</p>
<pre><code class="language-plain_text">  install(CODE &quot;MESSAGE(\&quot;Sample install message.\&quot;)&quot;)
</code></pre>
<p>会在安装时打印一条消息。</p>
<h4><a id="export%E7%89%88%E6%9C%AC%E7%9A%84install%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>EXPORT版本的install命令</h4>
<pre><code class="language-plain_text">install(EXPORT &lt;export-name&gt; DESTINATION &lt;dir&gt;
      [NAMESPACE &lt;namespace&gt;] [FILE &lt;name&gt;.cmake]
      [PERMISSIONS permissions...]
      [CONFIGURATIONS [Debug|Release|...]]
      [COMPONENT &lt;component&gt;])
</code></pre>
<p>EXPORT格式的install命令生成并安装一个包含将安装过程的安装树导入到另一个工程中的CMake文件。Target格式的安装过程与上文提及的使用EXPORT选项的install(TARGET ...)格式的命令中的EXPORT <export-name>选项是相关的。NAMESPACE选项会在它们被写入到导入文件时加到目标名字之前。缺省时，生成的文件就是<export-name>.cmake；但是FILE选项可以用来指定不同于次的文件名。FILE选项后面的参数必须是一“.cmake”为扩展名的文件。如果指定了CONFIGURATIONS选项，那么只有那些具名的配置中的一个被安装时，这个文件才会被安装。而且，生成的导入文件只能涉及到匹配的目标配置版本。如果指定了一个COMPONENT选项，并且<component>与那个<export-name>相关的目标指定的部件不匹配，那么行为是未定义的。如果一个库目标被包含在export之中，但是与之关联的库却没有背包含，那么结果是未指定的。</p>
<p>EXPORT格式可以协助外部工程使用当前工程构建出来并安装的目标。例如，代码</p>
<pre><code class="language-plain_text">  install(TARGETS myexe EXPORT myproj DESTINATION bin)
  install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)
</code></pre>
<p>将会把可执行文件myexe安装到<prefix>/bin下，并且将导入它的代码写到文件&quot;<prefix>/lib/myproj/myproj.cmake&quot;中。一个外部工程可以用include命令加载这个文件，并且可以在安装树上使用导入的目标名mp_myexe（前缀_目标名——译注）引用myexe可执行文件，如同这个目标是它自身的构建树的内置目标一样。</p>
<p>注意：这个命令会取代INSTALL_TARGETS命令以及PRE_INSTALL_SCRIPT和POST_INSTALL_SCRIPT两个目标属性。它也可以取代FILES格式的INSTALL_FILES命令和INSTALL_PROGRAMS命令。由INSTALL命令生成的安装规则相对于那些由INSTALL_TARGETS，INSTALL_FILES和INSTALL_PROGRAMS命令生成的安装规则处理顺序是未定义的。</p>
<h3><a id="make-clean" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>make clean</h3>
<p>清除编译产生的可执行文件及目标文件(object file，*.o)。</p>
<h2><a id="%E6%9F%A5%E8%A1%A8%E6%89%8B%E5%86%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查表手册</h2>
<h3><a id="cmake%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cmake 常用变量</h3>
<pre><code class="language-plain_text">CMAKE_BINARY_DIR
PROJECT_BINARY_DIR
&lt;projectname&gt;_BINARY_DIR
</code></pre>
<p>这三个变量指代的内容是一致的，如果是 in source 编译，指得就是工程顶层目录，如果是 out-of-source 编译，指的是工程编译发生的目录。</p>
<p>PROJECT_BINARY_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。</p>
<pre><code class="language-plain_text">CMAKE_SOURCE_DIR
PROJECT_SOURCE_DIR
&lt;projectname&gt;_SOURCE_DIR
</code></pre>
<p>这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。</p>
<p>也就是在 in source 编译时，他跟 CMAKE_BINARY_DIR 等变量一致。</p>
<p>PROJECT_SOURCE_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。</p>
<pre><code class="language-plain_text">CMAKE_CURRENT_SOURCE_DIR
</code></pre>
<p>指的是当前处理的 CMakeLists.txt 所在的路径，比如上面我们提到的 src 子目录。</p>
<pre><code class="language-plain_text">CMAKE_CURRRENT_BINARY_DIR
</code></pre>
<p>如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致，如果是 out-of-source 编译，他指的是 target 编译目录。</p>
<p>使用ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。</p>
<p>使用 SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径。</p>
<pre><code class="language-plain_text">CMAKE_CURRENT_LIST_FILE
</code></pre>
<p>输出调用这个变量的 CMakeLists.txt 的完整路径。</p>
<pre><code class="language-plain_text">CMAKE_CURRENT_LIST_LINE
</code></pre>
<p>输出这个变量所在的行。</p>
<pre><code class="language-plain_text">CMAKE_MODULE_PATH
</code></pre>
<p>这个变量用来定义自己的 cmake 模块所在的路径。</p>
<p>如果你的工程比较复杂,有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的,为了让 cmake 在处理CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。</p>
<p>比如<code>SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)</code>，这时候你就可以通过 INCLUDE 指令来调用自己的模块了。</p>
<pre><code class="language-plain_text">EXECUTABLE_OUTPUT_PATH
LIBRARY_OUTPUT_PATH
</code></pre>
<p>分别用来重新定义最终结果的存放目录。</p>
<pre><code class="language-plain_text">PROJECT_NAME
</code></pre>
<p>返回通过 PROJECT 指令定义的项目名称。</p>
<h3><a id="cmake%E8%B0%83%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cmake 调用环境变量的方式</h3>
<p>使用<code>$ENV{NAME}</code>指令就可以调用系统的环境变量了。</p>
<p>比如<code>MESSAGE(STATUS “HOME dir: $ENV{HOME}”)</code>。</p>
<p>设置环境变量的方式是:</p>
<pre><code class="language-plain_text">SET(ENV{变量名} 值)
</code></pre>
<pre><code class="language-plain_text">CMAKE_INCLUDE_CURRENT_DIR
</code></pre>
<p>自动添加 CMAKE_CURRENT_BINARY_DIR 和 CMAKE_CURRENT_SOURCE_DIR 到当前处理的 CMakeLists.txt。</p>
<p>相当于在每个 CMakeLists.txt 加入了如下两行：</p>
<pre><code class="language-plain_text">INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}
${CMAKE_CURRENT_SOURCE_DIR})
</code></pre>
<pre><code class="language-plain_text">CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE
</code></pre>
<p>将工程提供的头文件目录始终至于系统头文件目录的前面，当你定义的头文件确实跟系统发生冲突时可以提供一些帮助。</p>
<h3><a id="%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>系统信息</h3>
<p>1, <code>CMAKE_MAJOR_VERSION</code>，CMAKE 主版本号，比如 2.4.6 中的 2<br />
2, <code>CMAKE_MINOR_VERSION</code>，CMAKE 次版本号，比如 2.4.6 中的 4<br />
3, <code>CMAKE_PATCH_VERSION</code>，CMAKE 补丁等级，比如 2.4.6 中的 6<br />
4, <code>CMAKE_SYSTEM,系统名称</code>，比如 Linux-2.6.22<br />
5, <code>CMAKE_SYSTEM_NAME</code>，不包含版本的系统名,比如 Linux<br />
6, <code>CMAKE_SYSTEM_VERSION</code>，系统版本,比如 2.6.22<br />
7, <code>CMAKE_SYSTEM_PROCESSOR</code>，处理器名称,比如 i686.<br />
8, <code>UNIX</code>，在所有的类 UNIX 平台为 TRUE，包括 OS X 和 cygwin<br />
9, <code>WIN32</code>，在所有的 win32 平台为 TRUE，包括 cygwin</p>
<h3><a id="%E4%B8%BB%E8%A6%81%E7%9A%84%E5%BC%80%E5%85%B3%E9%80%89%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主要的开关选项</h3>
<p>1, <code>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</code>，用来控制 <code>IF ELSE</code> 语句的书写方式，在下一节语法部分会讲到。<br />
2, <code>BUILD_SHARED_LIBS</code>，这个开关用来控制默认的库编译方式，如果不进行设置，使用 <code>ADD_LIBRARY</code> 并没有指定库类型的情况下，默认编译生成的库都是静态库。如果 <code>SET(BUILD_SHARED_LIBS ON)</code>后,默认生成的为动态库。<br />
3,<code>CMAKE_C_FLAGS</code>，设置 C 编译选项,也可以通过指令 <code>ADD_DEFINITIONS()</code>添加。<br />
4,<code>CMAKE_CXX_FLAGS</code>，设置 C++编译选项,也可以通过指令 <code>ADD_DEFINITIONS()</code>添加。</p>
<h3><a id="cmake%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>cmake 常用指令</h3>
<h4><a id="%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本指令</h4>
<h5><a id="add-definitions" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ADD_DEFINITIONS</h5>
<p>向 C/C++编译器添加-D 定义，参数之间用空格分割。比如:</p>
<pre><code class="language-plain_text">ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)
</code></pre>
<p>如果你的代码中定义了<code>#ifdef ENABLE_DEBUG #endif</code>，这个代码块就会生效。</p>
<p>如果要添加其他的编译器开关,可以通过 <code>CMAKE_C_FLAGS</code> 变量和 <code>CMAKE_CXX_FLAGS</code> 变量设置。</p>
<h5><a id="add-dependencies" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ADD_DEPENDENCIES</h5>
<p>定义 target 依赖的其他 target，确保在编译本 target 之前,其他的 target 已经被构建。</p>
<pre><code class="language-plain_text">ADD_DEPENDENCIES(target-name depend-target1
                 depend-target2 ...)
</code></pre>
<h5><a id="add-test%E4%B8%8E-enable-testing%E6%8C%87%E4%BB%A4%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ADD_TEST 与 ENABLE_TESTING 指令。</h5>
<p>ENABLE_TESTING 指令用来控制 Makefile 是否构建 test 目标,涉及工程所有目录。语法很简单，没有任何参数，<code>ENABLE_TESTING()</code>，一般情况这个指令放在工程的主CMakeLists.txt 中。</p>
<p>ADD_TEST 指令的语法是:</p>
<pre><code class="language-plain_text">ADD_TEST(testname Exename arg1 arg2 ...)
</code></pre>
<p>testname 是自定义的 test 名称，Exename 可以是构建的目标文件也可以是外部脚本等等。</p>
<p>后面连接传递给可执行文件的参数，如果没有在同一个 CMakeLists.txt 中打开<code>ENABLE_TESTING()</code>指令,任何 ADD_TEST 都是无效的。</p>
<p>比如我们前面的 Helloworld 例子,可以在工程主 CMakeLists.txt 中添加</p>
<pre><code class="language-plain_text">ADD_TEST(mytest ${PROJECT_BINARY_DIR}/bin/main)
ENABLE_TESTING()
</code></pre>
<p>生成 Makefile 后,就可以运行 make test 来执行测试了。</p>
<h5><a id="aux-source-directory" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AUX_SOURCE_DIRECTORY</h5>
<p>基本语法是:</p>
<pre><code class="language-plain_text">AUX_SOURCE_DIRECTORY(dir VARIABLE)
</code></pre>
<p>作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。</p>
<p>比如</p>
<pre><code class="language-plain_text">AUX_SOURCE_DIRECTORY(. SRC_LIST)
ADD_EXECUTABLE(main ${SRC_LIST})
</code></pre>
<p>你也可以通过后面提到的 FOREACH 指令来处理这个 LIST。</p>
<h5><a id="cmake-minimum-required" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMAKE_MINIMUM_REQUIRED</h5>
<p>其语法为</p>
<pre><code class="language-plain_text">CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])
</code></pre>
<p>比如</p>
<pre><code class="language-plain_text">CMAKE_MINIMUM_REQUIRED(VERSION 2.5 FATAL_ERROR)
</code></pre>
<p>如果 cmake 版本小与 2.5,则出现严重错误,整个过程中止。</p>
<h5><a id="exec-program" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>EXEC_PROGRAM</h5>
<p>在 CMakeLists.txt 处理过程中执行命令，并不会在生成的 Makefile 中执行。</p>
<p>具体语法为:</p>
<pre><code class="language-plain_text">EXEC_PROGRAM(Executable [directory in which to run]
                [ARGS &lt;arguments to executable&gt;]
                [OUTPUT_VARIABLE &lt;var&gt;]
                [RETURN_VALUE &lt;var&gt;])
</code></pre>
<p>用于在指定的目录运行某个程序，通过 ARGS 添加参数,如果要获取输出和返回值，可通过OUTPUT_VARIABLE 和 RETURN_VALUE 分别定义两个变量。</p>
<p>这个指令可以帮助你在 CMakeLists.txt 处理过程中支持任何命令，比如根据系统情况去修改代码文件等等。</p>
<p>举个简单的例子,我们要在 src 目录执行 ls 命令,并把结果和返回值存下来。</p>
<p>可以直接在 src/CMakeLists.txt 中添加:</p>
<pre><code class="language-plain_text">EXEC_PROGRAM(ls ARGS &quot;*.c&quot; OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE
LS_RVALUE)
IF(not LS_RVALUE)
MESSAGE(STATUS &quot;ls result: &quot; ${LS_OUTPUT})
ENDIF(not LS_RVALUE)
</code></pre>
<p>在 cmake 生成 Makefile 的过程中，就会执行 ls 命令，如果返回 0，则说明成功执行，那么就输出 ls *.c 的结果。关于 IF 语句，后面的控制指令会提到。</p>
<h5><a id="file%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FILE 指令</h5>
<p>文件操作指令,基本语法为:</p>
<pre><code class="language-plain_text">FILE(WRITE filename &quot;message to write&quot;... )
FILE(APPEND filename &quot;message to write&quot;... )
FILE(READ filename variable)
FILE(GLOB variable [RELATIVE path] [globbing expression_r_rs]...)
FILE(GLOB_RECURSE variable [RELATIVE path] [globbing expression_r_rs]...)
FILE(REMOVE [directory]...)
FILE(REMOVE_RECURSE [directory]...)
FILE(MAKE_DIRECTORY [directory]...)
FILE(RELATIVE_PATH variable directory file)
FILE(TO_CMAKE_PATH path result)
FILE(TO_NATIVE_PATH path result)
</code></pre>
<h5><a id="include%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>INCLUDE 指令</h5>
<p>用来载入 CMakeLists.txt 文件,也用于载入预定义的 cmake 模块。</p>
<pre><code class="language-plain_text">INCLUDE(file1 [OPTIONAL])
INCLUDE(module [OPTIONAL])
</code></pre>
<p>OPTIONAL 参数的作用是文件不存在也不会产生错误。</p>
<p>你可以指定载入一个文件,如果定义的是一个模块，那么将在 CMAKE_MODULE_PATH 中搜索这个模块并载入。</p>
<p>载入的内容将在处理到 INCLUDE 语句是直接执行。</p>
<h4><a id="find%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FIND_指令</h4>
<p>FIND_系列指令主要包含一下指令:</p>
<pre><code class="language-plain_text"># VAR 变量代表找到的文件全路径,包含文件名
FIND_FILE(&lt;VAR&gt; name1 path1 path2 ...)

# VAR 变量表示找到的库全路径,包含库文件名
FIND_LIBRARY(&lt;VAR&gt; name1 path1 path2 ...)

# VAR 变量代表包含这个文件的路径。
FIND_PATH(&lt;VAR&gt; name1 path1 path2 ...)

# VAR 变量代表包含这个程序的全路径。
FIND_PROGRAM(&lt;VAR&gt; name1 path1 path2 ...)

# 用来调用预定义在 CMAKE_MODULE_PATH 下的 Find&lt;name&gt;.cmake 模块,你也可以自己定义 Find&lt;name&gt;模块,通过 SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录中供工程使用,我们在后面的章节会详细介绍 FIND_PACKAGE 的使用方法和 Find 模块的编写。
FIND_PACKAGE(&lt;name&gt; [major.minor] [QUIET] [NO_MODULE]
                [[REQUIRED|COMPONENTS] [componets...]])

</code></pre>
<p>FIND_LIBRARY 示例：</p>
<pre><code class="language-plain_text">FIND_LIBRARY(libX X11 /usr/lib)
IF(NOT libX)
MESSAGE(FATAL_ERROR “libX not found”)
ENDIF(NOT libX)
</code></pre>
<h5><a id="link-directories" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>link_directories</h5>
<p>指定连接器查找库的路径。</p>
<pre><code class="language-plain_text">link_directories(directory1 directory2 ...)
</code></pre>
<p>指定连接器搜索库文件时的路径。该命令仅仅能用在那些在它被调用后才生成的目标上。由于历史上的原因，为该命令指定的相对路径将会不加改变地传递给连接器（不像许多其他CMake命令那样解释为相对于当前源路径的相对路径。）</p>
<h4><a id="%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>控制指令:</h4>
<h5><a id="if%E6%8C%87%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>IF 指令</h5>
<p>基本语法为:</p>
<pre><code class="language-plain_text">IF(expression_r_r)
# THEN section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
 ...
ELSE(expression_r_r)
# ELSE section.
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
 ...
ENDIF(expression_r_r)
</code></pre>
<p>另外一个指令是 ELSEIF，总体把握一个原则，凡是出现 IF 的地方一定要有对应的ENDIF，出现 ELSEIF 的地方，ENDIF 是可选的。</p>
<p>表达式的使用方法如下:</p>
<pre><code class="language-plain_text">IF(var),如果变量不是:空,0,N, NO, OFF, FALSE, NOTFOUND 或&lt;var&gt;_NOTFOUND 时,表达式为真。
IF(NOT var ),与上述条件相反。
IF(var1 AND var2),当两个变量都为真是为真。
IF(var1 OR var2),当两个变量其中一个为真时为真。
IF(COMMAND cmd),当给定的 cmd 确实是命令并可以调用是为真。
IF(EXISTS dir)或者 IF(EXISTS file),当目录名或者文件名存在时为真。
IF(file1 IS_NEWER_THAN file2),当 file1 比 file2 新,或者 file1/file2 其中有一个不存在时为真,文件名请使用完整路径。
IF(IS_DIRECTORY dirname),当 dirname 是目录时,为真。
IF(variable MATCHES regex)
IF(string MATCHES regex)
</code></pre>
<p>当给定的变量或者字符串能够匹配正则表达式 regex 时为真。比如：</p>
<pre><code class="language-plain_text"># 数字比较表达式
IF(&quot;hello&quot; MATCHES &quot;ell&quot;)
MESSAGE(&quot;true&quot;)
ENDIF(&quot;hello&quot; MATCHES &quot;ell&quot;)
IF(variable LESS number)
IF(string LESS number)
IF(variable GREATER number)
IF(string GREATER number)
IF(variable EQUAL number)
IF(string EQUAL number)

# 按照字母序的排列进行比较.
IF(variable STRLESS string)
IF(string STRLESS string)
IF(variable STRGREATER string)
IF(string STRGREATER string)
IF(variable STREQUAL string)
IF(string STREQUAL string)

</code></pre>
<p><code>IF(DEFINED variable)</code>，如果变量被定义,为真。</p>
<p>一个小例子,用来判断平台差异:</p>
<pre><code class="language-plain_text">IF(WIN32)
    MESSAGE(STATUS “This is windows.”)
    #作一些 Windows 相关的操作
ELSE(WIN32)
    MESSAGE(STATUS “This is not windows”)
    #作一些非 Windows 相关的操作
ENDIF(WIN32)
</code></pre>
<p>上述代码用来控制在不同的平台进行不同的控制，但是，阅读起来却并不是那么舒服。</p>
<p>ELSE(WIN32)之类的语句很容易引起歧义。</p>
<p>这就用到了我们在“常用变量”一节提到的 <code>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</code> 开关。<br />
可以 <code>SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)</code></p>
<p>这时候就可以写成：</p>
<pre><code class="language-plain_text">IF(WIN32)
ELSE()
ENDIF()
</code></pre>
<p>如果配合 ELSEIF 使用，可能的写法是这样：</p>
<pre><code class="language-plain_text">IF(WIN32)
# do something related to WIN32
ELSEIF(UNIX)
# do something related to UNIX
ELSEIF(APPLE)
# do something related to APPLE
ENDIF(WIN32)
</code></pre>
<h5><a id="while" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>WHILE</h5>
<p>WHILE 指令的语法是:</p>
<pre><code class="language-plain_text">WHILE(condition)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ENDWHILE(condition)
</code></pre>
<p>其真假判断条件可以参考 IF 指令。</p>
<h5><a id="foreach" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FOREACH</h5>
<p>FOREACH 指令的使用方法有三种形式：</p>
<p>1 列表</p>
<pre><code class="language-plain_text">FOREACH(loop_var arg1 arg2 ...)
    COMMAND1(ARGS ...)
    COMMAND2(ARGS ...)
    ...
ENDFOREACH(loop_var)
</code></pre>
<p>像我们前面使用的 AUX_SOURCE_DIRECTORY 的例子：</p>
<pre><code class="language-plain_text">AUX_SOURCE_DIRECTORY(. SRC_LIST)
FOREACH(F ${SRC_LIST})
    MESSAGE(${F})
ENDFOREACH(F)
</code></pre>
<p>2 范围</p>
<pre><code class="language-plain_text">FOREACH(loop_var RANGE total)
ENDFOREACH(loop_var)
</code></pre>
<p>从 0 到 total 以1为步进。</p>
<p>举例如下:</p>
<pre><code class="language-plain_text">FOREACH(VAR RANGE 10)
MESSAGE(${VAR})
ENDFOREACH(VAR)
</code></pre>
<p>最终得到的输出是:</p>
<pre><code class="language-plain_text">0
1
2
3
4
5
6
7
8
9
10
</code></pre>
<p>3 范围和步进</p>
<pre><code class="language-plain_text">FOREACH(loop_var RANGE start stop [step])
ENDFOREACH(loop_var)
</code></pre>
<p>从 start 开始到 stop 结束,以 step 为步进。</p>
<p>举例如下：</p>
<pre><code class="language-plain_text">FOREACH(A RANGE 5 15 3)
MESSAGE(${A})
ENDFOREACH(A)
</code></pre>
<p>最终得到的结果是:</p>
<pre><code class="language-plain_text">5
8
11
14
</code></pre>
<p>这个指令需要注意的是,知道遇到 ENDFOREACH 指令,整个语句块才会得到真正的执行。</p>
<h2><a id="ios%E4%BD%BF%E7%94%A8cmake%E7%BC%96%E8%AF%91framework" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ios使用cmake编译framework</h2>
<p>编译方式采用cmake，toochain中为iOS工具链iOS.cmake，目录结构如下：</p>
<pre><code class="language-plain_text">├─ toochain
│  ├─ iOS.cmake
├─ CMakeLists.txt
├─ Info.plist
├─ ShellScript
</code></pre>
<h3><a id="cmake%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E5%A6%82%E4%B8%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CMake编译脚本如下：</h3>
<pre><code class="language-plain_text">#****************************This is Project Info****************************
PROJECT(SKYObject)
CMAKE_MINIMUM_REQUIRED(VERSION 2.8)

#****************************This is Compile Flag****************************
 if(DEBUG)
 message( STATUS &quot;==============================debug==============================&quot; )
 ADD_DEFINITIONS(-g)
 ADD_DEFINITIONS(-D AVX_DEBUG_LEVEL=AVX_DEBUG_DEBUG)
else(DEBUG)
 message( STATUS &quot;==============================release==============================&quot; )
 ADD_DEFINITIONS(-O2)
 ADD_DEFINITIONS(-D AVX_DEBUG_LEVEL=AVX_DEBUG_INFO)
 endif()

ADD_DEFINITIONS(&quot;-Wall&quot;)
ADD_DEFINITIONS(&quot;-fPIC&quot;)
ADD_DEFINITIONS(&quot;-Wl,-lm&quot;)
ADD_DEFINITIONS(&quot;-std=c++11&quot;)
SET(IPHONE_VERSION_MIN &quot;10.0&quot; CACHE STRING &quot;IOS minimum os version.&quot;)
SET(CMAKE_CXX_FLAGS &quot;-Wall -fPIC -Wl,-lm -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS&quot;)

SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fobjc-abi-version=2 -fobjc-arc -std=gnu++11 -stdlib=libc++ -isysroot ${CMAKE_OSX_SYSROOT} -framework AVX -miphoneos-version-min=${IPHONE_VERSION_MIN}&quot;)
SET(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -fobjc-abi-version=2 -fobjc-arc -isysroot ${CMAKE_OSX_SYSROOT} -framework AVX -miphoneos-version-min=${IPHONE_VERSION_MIN}&quot;)

#****************************This is Include File/Directories****************************
#INCLUDE_DIRECTORIES( ${CMAKE_CURRENT_SOURCE_DIR}/)
INCLUDE_DIRECTORIES(../../../)
INCLUDE_DIRECTORIES(../../../Library/Include)
INCLUDE_DIRECTORIES(../../../Library/IOS/include)
INCLUDE_DIRECTORIES(../../../Library/IOS/include/libevent)
INCLUDE_DIRECTORIES(../../../Include)
#****************************This is Source File/Directories****************************
#AUX_SOURCE_DIRECTORY(../../Object/ Object_SRCS)
AUX_SOURCE_DIRECTORY(../../../Source/ Source_SRCS)
SET(DIR_SRCS ${Source_SRCS})

#****************************This is Library Directories****************************
LINK_DIRECTORIES(./)
LINK_DIRECTORIES(../../../Bin/IOS)
LINK_DIRECTORIES(../../../Library/IOS/lib)

#****************************This is 3Party Library****************************
LINK_LIBRARIES(pthread dl)

#****************************This is Output Directory****************************
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/../../../Bin/IOS)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/../../../Bin/IOS)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/../../../Bin/IOS)

#****************************This is Output Library****************************
ADD_LIBRARY(${PROJECT_NAME} SHARED ${DIR_SRCS} )
TARGET_LINK_LIBRARIES(${PROJECT_NAME} pthread dl)
set_target_properties(${PROJECT_NAME} PROPERTIES FRAMEWORK TRUE MACOSX_FRAMEWORK_IDENTIFIER com.skylight.SKYObject MACOSX_FRAMEWORK_INFO_PLIST Info.plist PUBLIC_HEADER ../SKYObect.h XCODE_ATTRIBUTE_CODE_SIGN_IDENTITY &quot;iPhone Developer&quot;)
</code></pre>
<p>CMake说明：</p>
<ul>
<li>PROJECT(SKYObject)中SKYObject为framework的名字。</li>
<li>IPHONE_VERSION_MIN 为支持的iOS的最低系统，与Info.plist中MinimumOSVersion值相对应。</li>
<li>链接其他的framework使用-framework XXX。</li>
<li>INCLUDE_DIRECTORIES为头文件路径。</li>
<li>LINK_DIRECTORIES为库路径。</li>
<li>set_target_properties中MACOSX_FRAMEWORK_IDENTIFIER后边紧跟的值为Info.plist中CFBundleIdentifier，必须设置；MACOSX_FRAMEWORK_INFO_PLIST为使用自己的Info.plist模板，后边紧跟的值为Info.plist的相对路径；PUBLIC_HEADER指定需要的头文件，后边紧跟的值为头文件的相对路径。</li>
</ul>
<h3><a id="info-plist%E5%A6%82%E4%B8%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Info.plist如下：</h3>
<pre><code class="language-plain_text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
	&lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
	&lt;string&gt;English&lt;/string&gt;
	&lt;key&gt;CFBundleExecutable&lt;/key&gt;
	&lt;string&gt;SKYObject&lt;/string&gt;
	&lt;key&gt;CFBundleIdentifier&lt;/key&gt;
	&lt;string&gt;com.skylight.SKYObject&lt;/string&gt;
	&lt;key&gt;MinimumOSVersion&lt;/key&gt;
	&lt;string&gt;10.0&lt;/string&gt;
	&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
	&lt;string&gt;6.0&lt;/string&gt;
	&lt;key&gt;CFBundleName&lt;/key&gt;
	&lt;string&gt;SKYObject&lt;/string&gt;
	&lt;key&gt;CFBundlePackageType&lt;/key&gt;
	&lt;string&gt;FMWK&lt;/string&gt;
	&lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
	&lt;string&gt;1.0&lt;/string&gt;
	&lt;key&gt;CFBundleVersion&lt;/key&gt;
	&lt;string&gt;1&lt;/string&gt;
	&lt;key&gt;NSPrincipalClass&lt;/key&gt;
	&lt;string&gt;&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<h3><a id="shell%E8%84%9A%E6%9C%AC%E5%A6%82%E4%B8%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shell脚本如下：</h3>
<pre><code class="language-plain_text">#!/bin/bash
rm -rf CMakeCache.txt
rm -r CMakeFiles
rm -rf cmake_install.cmake
rm -rf Makefile
rm -rf CTestTestfile.cmake

if [ “$@“ =~ &quot;-d&quot; ];then
        echo &quot;----------------------------cmake debug----------------------------&quot;
        cmake -DDEBUG=ON -DCMAKE_TOOLCHAIN_FILE=./toolchain/IOS.cmake -DIOS_PLATFORM=OS -DBUILD_ARM64=1 .
else
        echo &quot;----------------------------cmake release----------------------------&quot;
        cmake -DDEBUG=NO -DCMAKE_TOOLCHAIN_FILE=./toolchain/IOS.cmake -DIOS_PLATFORM=OS -DBUILD_ARM64=1 .
fi

make

rm -rf CMakeCache.txt
rm -r CMakeFiles
rm -rf cmake_install.cmake~~~~
rm -rf Makefile
rm -rf CTestTestfile.cmake

install_name_tool -id @rpath/Frameworks/SKYObject.framework/SKYObject  ../../../Bin/IOS/SKYObject.framework/SKYObject

</code></pre>
<h3><a id="toochain%E5%B7%A5%E5%85%B7%E9%93%BEios-cmake%E5%A6%82%E4%B8%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>toochain工具链iOS.cmake如下：</h3>
<pre><code class="language-plain_text"># This file is based off of the Platform/Darwin.cmake and Platform/UnixPaths.cmake
# files which are included with CMake 2.8.4
# It has been altered for iOS development

# Options:
#
# IOS_PLATFORM = OS (default) or SIMULATOR or SIMULATOR64
#   This decides if SDKS will be selected from the iPhoneOS.platform or iPhoneSimulator.platform folders
#   OS - the default, used to build for iPhone and iPad physical devices, which have an arm arch.
#   SIMULATOR - used to build for the Simulator platforms, which have an x86 arch.
#
# CMAKE_IOS_DEVELOPER_ROOT = automatic(default) or /path/to/platform/Developer folder
#   By default this location is automatcially chosen based on the IOS_PLATFORM value above.
#   If set manually, it will override the default location and force the user of a particular Developer Platform
#
# CMAKE_IOS_SDK_ROOT = automatic(default) or /path/to/platform/Developer/SDKs/SDK folder
#   By default this location is automatcially chosen based on the CMAKE_IOS_DEVELOPER_ROOT value.
#   In this case it will always be the most up-to-date SDK found in the CMAKE_IOS_DEVELOPER_ROOT path.
#   If set manually, this will force the use of a specific SDK version

# Macros:
#
# set_xcode_property (TARGET XCODE_PROPERTY XCODE_VALUE)
#  A convenience macro for setting xcode specific properties on targets
#  example: set_xcode_property (myioslib IPHONEOS_DEPLOYMENT_TARGET &quot;3.1&quot;)
#
# find_host_package (PROGRAM ARGS)
#  A macro used to find executable programs on the host system, not within the iOS environment.
#  Thanks to the android-cmake project for providing the command

# Standard settings
set (CMAKE_SYSTEM_NAME Darwin)
set (CMAKE_SYSTEM_VERSION 1)
set (UNIX True)
set (APPLE True)
set (IOS True)

# Required as of cmake 2.8.10
set (CMAKE_OSX_DEPLOYMENT_TARGET &quot;&quot; CACHE STRING &quot;Force unset of the deployment target for iOS&quot; FORCE)

# Determine the cmake host system version so we know where to find the iOS SDKs
find_program (CMAKE_UNAME uname /bin /usr/bin /usr/local/bin)
if (CMAKE_UNAME)
	exec_program(uname ARGS -r OUTPUT_VARIABLE CMAKE_HOST_SYSTEM_VERSION)
	string (REGEX REPLACE &quot;^([0-9]+)\\.([0-9]+).*$&quot; &quot;\\1&quot; DARWIN_MAJOR_VERSION &quot;${CMAKE_HOST_SYSTEM_VERSION}&quot;)
endif (CMAKE_UNAME)

# Force the compilers to gcc for iOS
include (CMakeForceCompiler)
CMAKE_FORCE_C_COMPILER (/usr/bin/gcc Apple)
CMAKE_FORCE_CXX_COMPILER (/usr/bin/g++ Apple)
set(CMAKE_AR ar CACHE FILEPATH &quot;&quot; FORCE)

# Skip the platform compiler checks for cross compiling
set (CMAKE_CXX_COMPILER_WORKS TRUE)
set (CMAKE_C_COMPILER_WORKS TRUE)

# All iOS/Darwin specific settings - some may be redundant
set (CMAKE_SHARED_LIBRARY_PREFIX &quot;lib&quot;)
set (CMAKE_SHARED_LIBRARY_SUFFIX &quot;.dylib&quot;)
set (CMAKE_SHARED_MODULE_PREFIX &quot;lib&quot;)
set (CMAKE_SHARED_MODULE_SUFFIX &quot;.so&quot;)
set (CMAKE_MODULE_EXISTS 1)
set (CMAKE_DL_LIBS &quot;&quot;)

set (CMAKE_C_OSX_COMPATIBILITY_VERSION_FLAG &quot;-compatibility_version &quot;)
set (CMAKE_C_OSX_CURRENT_VERSION_FLAG &quot;-current_version &quot;)
set (CMAKE_CXX_OSX_COMPATIBILITY_VERSION_FLAG &quot;${CMAKE_C_OSX_COMPATIBILITY_VERSION_FLAG}&quot;)
set (CMAKE_CXX_OSX_CURRENT_VERSION_FLAG &quot;${CMAKE_C_OSX_CURRENT_VERSION_FLAG}&quot;)

# Hidden visibilty is required for cxx on iOS 
set (CMAKE_C_FLAGS_INIT &quot;&quot;)
set (CMAKE_CXX_FLAGS_INIT &quot;-fvisibility=hidden -fvisibility-inlines-hidden&quot;)

set (CMAKE_C_LINK_FLAGS &quot;-Wl,-search_paths_first ${CMAKE_C_LINK_FLAGS}&quot;)
set (CMAKE_CXX_LINK_FLAGS &quot;-Wl,-search_paths_first ${CMAKE_CXX_LINK_FLAGS}&quot;)

set (CMAKE_PLATFORM_HAS_INSTALLNAME 1)
set (CMAKE_SHARED_LIBRARY_CREATE_C_FLAGS &quot;-dynamiclib -headerpad_max_install_names&quot;)
set (CMAKE_SHARED_MODULE_CREATE_C_FLAGS &quot;-bundle -headerpad_max_install_names&quot;)
set (CMAKE_SHARED_MODULE_LOADER_C_FLAG &quot;-Wl,-bundle_loader,&quot;)
set (CMAKE_SHARED_MODULE_LOADER_CXX_FLAG &quot;-Wl,-bundle_loader,&quot;)
set (CMAKE_FIND_LIBRARY_SUFFIXES &quot;.dylib&quot; &quot;.so&quot; &quot;.a&quot;)

# hack: if a new cmake (which uses CMAKE_INSTALL_NAME_TOOL) runs on an old build tree
# (where install_name_tool was hardcoded) and where CMAKE_INSTALL_NAME_TOOL isn't in the cache
# and still cmake didn't fail in CMakeFindBinUtils.cmake (because it isn't rerun)
# hardcode CMAKE_INSTALL_NAME_TOOL here to install_name_tool, so it behaves as it did before, Alex
if (NOT DEFINED CMAKE_INSTALL_NAME_TOOL)
	find_program(CMAKE_INSTALL_NAME_TOOL install_name_tool)
endif (NOT DEFINED CMAKE_INSTALL_NAME_TOOL)

# Setup iOS platform unless specified manually with IOS_PLATFORM
if (NOT DEFINED IOS_PLATFORM)
	set (IOS_PLATFORM &quot;OS&quot;)
endif (NOT DEFINED IOS_PLATFORM)
set (IOS_PLATFORM ${IOS_PLATFORM} CACHE STRING &quot;Type of iOS Platform&quot;)

# Setup building for arm64 or not
if (NOT DEFINED BUILD_ARM64)
    set (BUILD_ARM64 true)
endif (NOT DEFINED BUILD_ARM64)
set (BUILD_ARM64 ${BUILD_ARM64} CACHE STRING &quot;Build arm64 arch or not&quot;)

# Check the platform selection and setup for developer root
if (${IOS_PLATFORM} STREQUAL &quot;OS&quot;)
	set (IOS_PLATFORM_LOCATION &quot;iPhoneOS.platform&quot;)

	# This causes the installers to properly locate the output libraries
	set (CMAKE_XCODE_EFFECTIVE_PLATFORMS &quot;-iphoneos&quot;)
elseif (${IOS_PLATFORM} STREQUAL &quot;SIMULATOR&quot;)
    set (SIMULATOR true)
	set (IOS_PLATFORM_LOCATION &quot;iPhoneSimulator.platform&quot;)

	# This causes the installers to properly locate the output libraries
	set (CMAKE_XCODE_EFFECTIVE_PLATFORMS &quot;-iphonesimulator&quot;)
elseif (${IOS_PLATFORM} STREQUAL &quot;SIMULATOR64&quot;)
    set (SIMULATOR true)
	set (IOS_PLATFORM_LOCATION &quot;iPhoneSimulator.platform&quot;)

	# This causes the installers to properly locate the output libraries
	set (CMAKE_XCODE_EFFECTIVE_PLATFORMS &quot;-iphonesimulator&quot;)
else (${IOS_PLATFORM} STREQUAL &quot;OS&quot;)
	message (FATAL_ERROR &quot;Unsupported IOS_PLATFORM value selected. Please choose OS or SIMULATOR&quot;)
endif (${IOS_PLATFORM} STREQUAL &quot;OS&quot;)

# Setup iOS developer location unless specified manually with CMAKE_IOS_DEVELOPER_ROOT
# Note Xcode 4.3 changed the installation location, choose the most recent one available
exec_program(/usr/bin/xcode-select ARGS -print-path OUTPUT_VARIABLE CMAKE_XCODE_DEVELOPER_DIR)
set (XCODE_POST_43_ROOT &quot;${CMAKE_XCODE_DEVELOPER_DIR}/Platforms/${IOS_PLATFORM_LOCATION}/Developer&quot;)
set (XCODE_PRE_43_ROOT &quot;/Developer/Platforms/${IOS_PLATFORM_LOCATION}/Developer&quot;)
if (NOT DEFINED CMAKE_IOS_DEVELOPER_ROOT)
	if (EXISTS ${XCODE_POST_43_ROOT})
		set (CMAKE_IOS_DEVELOPER_ROOT ${XCODE_POST_43_ROOT})
	elseif(EXISTS ${XCODE_PRE_43_ROOT})
		set (CMAKE_IOS_DEVELOPER_ROOT ${XCODE_PRE_43_ROOT})
	endif (EXISTS ${XCODE_POST_43_ROOT})
endif (NOT DEFINED CMAKE_IOS_DEVELOPER_ROOT)
set (CMAKE_IOS_DEVELOPER_ROOT ${CMAKE_IOS_DEVELOPER_ROOT} CACHE PATH &quot;Location of iOS Platform&quot;)

# Find and use the most recent iOS sdk unless specified manually with CMAKE_IOS_SDK_ROOT
if (NOT DEFINED CMAKE_IOS_SDK_ROOT)
	file (GLOB _CMAKE_IOS_SDKS &quot;${CMAKE_IOS_DEVELOPER_ROOT}/SDKs/*&quot;)
	if (_CMAKE_IOS_SDKS) 
		list (SORT _CMAKE_IOS_SDKS)
		list (REVERSE _CMAKE_IOS_SDKS)
		list (GET _CMAKE_IOS_SDKS 0 CMAKE_IOS_SDK_ROOT)
	else (_CMAKE_IOS_SDKS)
		message (FATAL_ERROR &quot;No iOS SDK's found in default search path ${CMAKE_IOS_DEVELOPER_ROOT}. Manually set CMAKE_IOS_SDK_ROOT or install the iOS SDK.&quot;)
	endif (_CMAKE_IOS_SDKS)
	message (STATUS &quot;Toolchain using default iOS SDK: ${CMAKE_IOS_SDK_ROOT}&quot;)
endif (NOT DEFINED CMAKE_IOS_SDK_ROOT)
set (CMAKE_IOS_SDK_ROOT ${CMAKE_IOS_SDK_ROOT} CACHE PATH &quot;Location of the selected iOS SDK&quot;)

# Set the sysroot default to the most recent SDK
set (CMAKE_OSX_SYSROOT ${CMAKE_IOS_SDK_ROOT} CACHE PATH &quot;Sysroot used for iOS support&quot;)

# set the architecture for iOS armv7 armv7s
if (${IOS_PLATFORM} STREQUAL &quot;OS&quot;)
    set (IOS_ARCH  arm64)
elseif (${IOS_PLATFORM} STREQUAL &quot;SIMULATOR&quot;)
    set (IOS_ARCH i386)
elseif (${IOS_PLATFORM} STREQUAL &quot;SIMULATOR64&quot;)
    set (IOS_ARCH x86_64)
endif (${IOS_PLATFORM} STREQUAL &quot;OS&quot;)

set (CMAKE_OSX_ARCHITECTURES ${IOS_ARCH} CACHE string  &quot;Build architecture for iOS&quot;)

# Set the find root to the iOS developer roots and to user defined paths
set (CMAKE_FIND_ROOT_PATH ${CMAKE_IOS_DEVELOPER_ROOT} ${CMAKE_IOS_SDK_ROOT} ${CMAKE_PREFIX_PATH} CACHE string  &quot;iOS find search path root&quot;)

# default to searching for frameworks first
set (CMAKE_FIND_FRAMEWORK FIRST)

# set up the default search directories for frameworks
set (CMAKE_SYSTEM_FRAMEWORK_PATH
	${CMAKE_IOS_SDK_ROOT}/System/Library/Frameworks
	${CMAKE_IOS_SDK_ROOT}/System/Library/PrivateFrameworks
	${CMAKE_IOS_SDK_ROOT}/Developer/Library/Frameworks
)

# only search the iOS sdks, not the remainder of the host filesystem
set (CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY)
set (CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set (CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)


# This little macro lets you set any XCode specific property
macro (set_xcode_property TARGET XCODE_PROPERTY XCODE_VALUE)
	set_property (TARGET ${TARGET} PROPERTY XCODE_ATTRIBUTE_${XCODE_PROPERTY} ${XCODE_VALUE})
endmacro (set_xcode_property)


# This macro lets you find executable programs on the host system
macro (find_host_package)
	set (CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
	set (CMAKE_FIND_ROOT_PATH_MODE_LIBRARY NEVER)
	set (CMAKE_FIND_ROOT_PATH_MODE_INCLUDE NEVER)
	set (IOS FALSE)

	find_package(${ARGN})

	set (IOS TRUE)
	set (CMAKE_FIND_ROOT_PATH_MODE_PROGRAM ONLY)
	set (CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
	set (CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endmacro (find_host_package)



</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="17001161339218.html" 
          title="Previous Post: 人为什么会过分自信">&laquo; 人为什么会过分自信</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="17001875302773.html" 
          title="Next Post: LeetCode 8 String to Integer (atoi)">LeetCode 8 String to Integer (atoi) &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>DreamEverAfter</h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Pages.html"><strong>Pages</strong></a>
        
            <a href="CS.html"><strong>CS</strong></a>
        
            <a href="List.html"><strong>List</strong></a>
        
            <a href="%E6%9D%82.html"><strong>杂</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="17016988559065.html">差生文具多</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16996865532784.html">三汁焖锅</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001172774052.html">别了，中国大陆的Kindle</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001265068678.html">HomeBrew更新报错“fatal- Could not resolve HEAD to a revision”</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001892553950.html">SwiftUI基本控件</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
