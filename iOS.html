<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  iOS - DreamEverAfter
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="DreamEverAfter" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.dreameverafter.com ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="tools.html">工具</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; DreamEverAfter</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="tools.html">工具</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="CS.html">CS</a></li>
        
            <li><a href="List.html">List</a></li>
        
            <li><a href="%E6%9D%82.html">杂</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="17001892553950.html">
                
                  <h1>SwiftUI基本控件</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>准备用SwiftUI撸个小项目玩一下，边做边记录用到的东西。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="17001892553950.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2022/06/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UI.html'>UI</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892555760.html">
                
                  <h1>Swift Module 如何被全局引用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>今天一个iOS大佬问我一个小问题，他用 <code>cocoapods</code> 集成了一个 <code>swift</code> 的 <code>json</code> 库：<code>SwiftyJSON</code>，用的时候发现有一丝丝不方便的地方，就是在每个用到 <code>SwiftyJSON</code> 的文件中，都需要 <code>import</code> 一下这个 <code>module</code>。</p>
<p>平时他在主工程里写代码的时候，由于都在一个 <code>module</code> 之下，所以基本上没有怎么用过 <code>import</code> 了，所以问我为什么会这样，以及有没有一个类似于 <code>PCH</code> 的文件，把 <code>SwiftyJSON</code> 全局引用。</p>
<p>至于为什么会这样，其实刚刚已经说了，就是因为没有在一个 <code>module</code> 中嘛。有没有类似 <code>PCH</code> 的东西呢，其实也是有的。</p>
<p>可以直接创建一个 <code>swift</code> 文件（类似 <code>PCH</code> ），在这个文件中使用 <code>@_exported import</code> 来导入：</p>
<pre><code class="language-swift">@_exported import SwiftyJSON 
</code></pre>
<p>这就好了，没错，智慧就是这么简单。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/11/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Swift.html'>Swift</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892556510.html">
                
                  <h1>浅谈iOS中的weak</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="weak%E6%8E%A2%E7%A9%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>__weak探究</h2>
<p>程序中添加了一个 <code>__weak</code> 变量，查看调用堆栈，看到下一个调用的是 <code>objc_initWeak</code> 函数。</p>
<p><img src="https://gitee.com/anyanf/images/raw/master/img/weak%E5%85%A5%E5%8F%A3.jpg" alt="__weak调用的函数" /></p>
<p>所以我们就 <code>objc_initWeak</code> 函数作为入口，探究 <code>weak</code>。</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据结构</h2>
<p>首先了解以下的变量，这些变量在这章的数据结构、函数形参中使用：</p>
<pre><code class="language-swift">__weak id weakPtr = o
location            newObj
refferer            reffenent
引用者               被引用者
</code></pre>
<h3><a id="stripedmap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StripedMap</h3>
<p>下面从 <code>SideTables()</code> 函数为入口，了解 <code>weak</code> 相关的数据结构。</p>
<pre><code class="language-CPP">static StripedMap&lt;SideTable&gt;&amp; SideTables() {
    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);
}
</code></pre>
<p>这个函数返回 <code>StripedMap</code> 结构，<code>StripedMap</code> 是一个模板类，函数体内将SideTableBuf强制转换为 <code>StripedMap&lt;SideTable&gt;</code></p>
<p><code>StripedMap</code> 定义如下：</p>
<pre><code class="language-CPP">template&lt;typename T&gt;
class StripedMap {
    struct PaddedT {
        T value alignas(64);
    };

    PaddedT array[64];
};
</code></pre>
<p>上面代码是 <code>StripedMap</code> 的简化定义，<code>StripedMap</code> 是个模板类，根据模板参数 <code>T</code> 生成实例类，我们给模板参数传递的实参是 <code>SideTable</code>，<code>StripedMap</code> 内部只定义了一个数据成员 <code>PaddedT array[64]</code>，<code>PaddedT</code> 就是 <code>64</code> 位对齐后的 <code>SideTable</code>。</p>
<p>进一步简化：</p>
<pre><code class="language-cpp">SideTable array[64];
</code></pre>
<p>所以 <code>StripedMap</code> 就是 <code>SideTable</code> 型的数组，数组有 <code>64</code> 个成员。</p>
<p><code>SideTable</code> 的结构如下：</p>
<pre><code class="language-cpp">struct SideTable {
    spinlock_t slock;
    RefcountMap refcnts;
    weak_table_t weak_table;
}
</code></pre>
<p><img src="https://gitee.com/anyanf/images/raw/master/img/weak_sideTable.png" alt="weak_sideTable" /></p>
<p>可以看出SideTable的大小是62，64位对齐后是64。其中weak_talbe存储着weak相关的内容。其他的两个成员refcnts、slock不在本文的研究范围内。</p>
<p>所以数组 <code>SideTable array[64]</code> 中元素的大小就是 <code>64</code>。整个 <code>array</code> 共占用 <code>64*64=4096</code> 字节。回到没有简化前的版本，<code>StripedMap&lt;SideTable&gt;</code> 本质是一个数组，数组的元素是模板参数类型 — <code>SideTable</code>，大小为 <code>64</code>。</p>
<p><img src="https://gitee.com/anyanf/images/raw/master/img/stripmap_memory_struct.png" alt="StripedMap 内存结构" /></p>
<p>函数 <code>SideTables()</code> 是将 <code>SideTableBuf</code> 转化为 <code>StripedMap&lt;SideTable&gt;</code> 的。所以下面了解 <code>SideTableBuf</code> 的定义。</p>
<h3><a id="sidetablebuf" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SideTableBuf</h3>
<p>SideTableBuf的定义：</p>
<pre><code class="language-cpp">alignas(StripedMap&lt;SideTable&gt;) static uint8_t
    SideTableBuf[sizeof(StripedMap&lt;SideTable&gt;)];
</code></pre>
<p>前面的 <code>alignas(StripedMap)</code> 是对齐的。<code>sizeof(StripedMap&lt;SideTable&gt;)</code> 根据上面分析是 <code>4096</code>，所以上面的代码简化为：</p>
<pre><code class="language-cpp">static uint8_t SideTableBuf[4096];
</code></pre>
<p>所以 <code>SideTableBuf</code> 就是一个包含 <code>4096</code> 个 <code>uint8_t</code> 的数组 。</p>
<p>所以，函数 <code>SideTables()</code> 就相当将 <code>uint8_t SideTableBuf[4096]</code> 重新解释为 <code>SideTable array[64]</code>。</p>
<pre><code class="language-cpp">static StripedMap&lt;SideTable&gt;&amp; SideTables() {
    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);
}
</code></pre>
<p><img src="https://gitee.com/anyanf/images/raw/master/img/stripedMap.png" alt="SideTableBuf转化为StripedMap 内存示意图" /></p>
<h3><a id="weak-table-t" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>weak_table_t</h3>
<pre><code class="language-cpp">// 全局的弱引用表
struct weak_table_t {
    weak_entry_t *weak_entries; 
    size_t    num_entries; // 实体的数量
    uintptr_t mask;
    uintptr_t max_hash_displacement;
};
</code></pre>
<ol>
<li><code>weak_entries</code> 一个数组，数组每个元素是 <code>weak_entry_t</code> 结构体，一个 <code>weak_entry_t</code> 结构存储了一个 <code>reffenent</code>，以及指向 <code>reffenent</code> 的弱引用者们。</li>
<li><code>num_entries</code> 是实体 <code>weak_entry_t</code> 的数量</li>
<li><code>mask</code> 是容量减 <code>1</code>.</li>
</ol>
<h3><a id="weak-entry-t" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>weak_entry_t</h3>
<pre><code class="language-cpp">struct weak_entry_t {
    DisguisedPtr&lt;objc_object&gt; referent; 
    union {
        struct {
            weak_referrer_t *referrers; 
            uintptr_t        out_of_line : 1; // 变量名是 out_of_line ，占 1 个 bit
            uintptr_t        num_refs : PTR_MINUS_1; // 数组中有几个元素，即 referent 有几个弱引用
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line=0 is LSB of one of these (don't care which)
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
};
</code></pre>
<p>这个结构看着比较复杂：</p>
<ol>
<li><code>referent</code> 存储被弱引用的对象。</li>
<li>第二个成员是一个 <code>union</code>，存储弱引用者 <code>refferer</code>。如果 <code>referent</code> 的弱引用者小于四个，也就是 <code>out_of_line</code> 为 <code>0</code> 时，弱引用者就存储在 <code>inline_referrers</code> 数组中。 否则，就存储在 <code>referrers</code> 中，这时 <code>out_of_line</code> 为 <code>1</code>，<code>referrers</code> 是个二级指针，里面存的是指向 <code>referent</code> 的对象们的地址。<code>num_refs</code> 是弱引用着的个数。<code>mask</code> 是容量减 <code>1</code>。</li>
</ol>
<p><img src="https://gitee.com/anyanf/images/raw/master/img/weak_entry_t.png" alt="SideTableBuf转化为StripedMap" /></p>
<h3><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h3>
<p>上面分析了weak相关的结构，现在画一张总图：</p>
<p><img src="https://gitee.com/anyanf/images/raw/master/img/weak_data_overal.png" alt="SideTableBuf转化为StripedMap" /></p>
<p>上面是详细的数据结构，比较复杂，下面列出我认为核心的结构，核心结构就是三级hash表。</p>
<p><img src="https://gitee.com/anyanf/images/raw/master/img/weak_table%E4%B8%89%E7%BA%A7%E8%A1%A8.png" alt="SideTableBuf转化为StripedMap" /></p>
<h2><a id="%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数接口</h2>
<pre><code class="language-cpp">id objc_storeWeakOrNil(id *location, id newObj);
id objc_initWeak(id *location, id newObj);
void objc_destroyWeak(id *location);
</code></pre>
<p>下面章节的代码只是简化的代码，为了方便理解，可能缺失部分细节。</p>
<h3><a id="objc-initweak" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>objc_initWeak</h3>
<pre><code class="language-cpp">id
objc_initWeak(id *location, id newObj)
{
    if (!newObj) {
        *location = nil;
        return nil;
    }

    return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;
        (location, (objc_object*)newObj);
}
</code></pre>
<p><code>objc_initWeak</code> 内部只调用了 <code>storeWeak</code> 函数。</p>
<h3><a id="objc-storeweak" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>objc_storeWeak</h3>
<pre><code class="language-cpp">id
objc_storeWeak(id *location, id newObj)
{

    return storeWeak&lt;true/*old*/,
                    true/*new*/,
                    true/*crash*/&gt;
        (location, (objc_object *)newObj);
}
</code></pre>
<h3><a id="objc-destroyweak" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>objc_destroyWeak</h3>
<pre><code class="language-cpp">objc_destroyWeak(id *location)
{
    (void)storeWeak&lt;true/*old*/, false/*new*/, false/*crash*/&gt;
        (location, nil);
}
</code></pre>
<p>可以看出 <code>objc_initWeak</code>、 <code>objc_storeWeak</code>、 <code>objc_destroyWeak</code> 的关键内容都是调用 <code>storeWeak</code> 函数，只是模板参数传递的不一样。</p>
<h3><a id="storeweak" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>storeWeak</h3>
<p>下面讲解storeWeak函数，下面只关注添加的过程。删除的过程没有关注。</p>
<pre><code class="language-cpp">template &lt;HaveOld haveOld, HaveNew haveNew,
          CrashIfDeallocating crashIfDeallocating&gt;
static id 
storeWeak(id *location, objc_object *newObj)
{
    assert(haveOld  ||  haveNew);
    if (!haveNew) assert(newObj == nil);

    Class previouslyInitializedClass = nil;
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;

    if (haveNew) {
        newTable = &amp;SideTables()[newObj];
    } else {
        newTable = nil;
    }


    // Assign new value, if any.
    if (haveNew) {
        newObj = (objc_object *)
            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, 
                                  crashIfDeallocating);
    }
    return (id)newObj;
}
</code></pre>
<pre><code class="language-cpp">if (haveNew) {
        newTable = &amp;SideTables()[newObj];
    } else {
        newTable = nil;
    }
</code></pre>
<p>就是根据 <code>newObj</code> 找到存储 <code>newObj</code> 的地址对应的 <code>SideTable</code>。</p>
<pre><code class="language-cpp">static unsigned int indexForPointer(const void *p) {
       uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p);
       return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount;
}

public:
   T&amp; operator[] (const void *p) { 
       return array[indexForPointer(p)].value; 
}
</code></pre>
<p><code>StripedMap</code> 重载了 <code>[]</code> 操作符，内部调用了 <code>indexForPointer</code>，<code>indexForPointer</code> 就是将对象的地址做某些操作，相当于 <code>hash</code>。然后将 <code>hash</code> 的结果和 <code>64</code> 取余，得到 <code>0~63</code> 的值，这个值就可以当做数组的索引使用。</p>
<p><code>storeWeak</code> 函数接着调用了 <code>weak_register_no_lock</code> 函数：</p>
<pre><code class="language-cpp">id 
weak_register_no_lock(weak_table_t *weak_table, id referent_id, 
                      id *referrer_id, bool crashIfDeallocating)
{
    objc_object *referent = (objc_object *)referent_id;
    objc_object **referrer = (objc_object **)referrer_id;  

    // now remember it and where it is being stored
    weak_entry_t *entry;
    // 找到 referent 所在的 entry
    if ((entry = weak_entry_for_referent(weak_table, referent))) {
        // 将 referrer 添加进这个 entry 中，这样 referrer 就成为 referent 的弱引用之一了
        append_referrer(entry, referrer);
    }
    // 如果没有找到对应的 entry ，那么说明 referent 还没有弱引用，就为其新建一个 entry
    else {
        weak_entry_t new_entry;
        new_entry.referent = referent;
        new_entry.out_of_line = 0;
        new_entry.inline_referrers[0] = referrer;
        // 数组中 4 个referrer全部初始化为 nil
        for (size_t i = 1; i &lt; WEAK_INLINE_COUNT; i++) {
            new_entry.inline_referrers[i] = nil;
        }
        // 检查一下需不需要扩容
        weak_grow_maybe(weak_table);
        // 将新建的 entry 插入 weak table 中
        weak_entry_insert(weak_table, &amp;new_entry);
    }
    return referent_id;
}
</code></pre>
<p>这个函数的功能就是讲 <code>referrer_id</code> 插入到正确的位置，分为两种情况：</p>
<ol>
<li>如果根据 <code>referent_id</code> 可以找到一个 <code>weak_entry_t</code> 类型的实体 <code>entry</code>，就调用将 <code>append_referrer</code> 将 <code>referrer_id</code> 插入到 <code>entry</code>（相当于三级hash表）中。</li>
<li>如果没有，就需要新建一个 <code>weak_entry_t</code> 类型的实体 <code>new_entry</code>。然后调用 <code>weak_entry_insert</code> 将 <code>new_entry</code> 插入到二级hash表中。</li>
</ol>
<pre><code class="language-cpp">static weak_entry_t *
weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)
{
    // 不能是 nil
    assert(referent);

    // weak_table 中存的实体数组
    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;

    if (!weak_entries) {
        return nil;
    }

    // 通过 Hash 的方法找到 referent 所在的索引，不过实在看不懂
    size_t index = hash_pointer(referent) &amp; weak_table-&gt;mask;
    size_t hash_displacement = 0;
    while (weak_table-&gt;weak_entries[index].referent != referent) {
        index = (index+1) &amp; weak_table-&gt;mask;
        hash_displacement++;
        if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) {
            return nil;
        }
    }
    
    // 返回找到的 weak_entry_t，这里可以证明 weak_entries 确实是一个数组
    return &amp;weak_table-&gt;weak_entries[index];
}
</code></pre>
<p><code>weak_entry_for_referent</code> 根据给的的 <code>referent</code> 在 <code>weak_table-&gt;weak_entries</code> 中遍历，是否有相同的，如果相同就返回对应的 <code>weak_entry_t</code> 类型的实体，如果没有 <code>nil</code>。</p>
<p><code>hash_pointer</code> 就是对对象 <code>referent</code> 的地址做个 <code>hash</code>，然后和 <code>weak_table-&gt;mask</code> 做<code>与</code>操作，返回的结果小于 <code>weak_table-&gt;mask</code> ，当做数组的索引。</p>
<p><code>hash_displacement</code> 记录的就是最佳位置和实际存储位置的偏移量。</p>
<pre><code class="language-cpp">static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)
{
    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;
    assert(weak_entries != nil);

    // 通过 hash 决定 索引
    size_t index = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);
    size_t hash_displacement = 0;
    
    // 如果该索引中已经有 entry，那么这个索引就不能用了，就找下一个索引
    while (weak_entries[index].referent != nil) {
        index = (index+1) &amp; weak_table-&gt;mask;
        hash_displacement++;
    }

    // 将 new_entry 放入指定的索引中
    weak_entries[index] = *new_entry;
    weak_table-&gt;num_entries++;

    if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) {
        weak_table-&gt;max_hash_displacement = hash_displacement;
    }
}
</code></pre>
<p><code>weak_entry_insert</code> 就是在二级 <code>hash</code> 表中插入一个新的实体 <code>new_entry</code>。通过 <code>hash_pointer</code> 找到一个最佳位置 <code>index</code>，如果最佳位置已经有内容了，就接着查找下一个位置，直到找到空位置。记录下 <code>index</code>。在 <code>index</code> 处插入 <code>new_entry</code>。同时将 <code>num_entries</code> 累加 <code>1</code>。</p>
<pre><code class="language-cpp">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)
{
    // out_of_line == 0 的情况
    if (! entry-&gt;out_of_line) {
        // Try to insert inline.
        // inline_referrers 还放得下，就放在 inline_referrers 里
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            if (entry-&gt;inline_referrers[i] == nil) {
                entry-&gt;inline_referrers[i] = new_referrer;
                return;
            }
        }

        weak_referrer_t *new_referrers = (weak_referrer_t *)
            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));
    
        
        // 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中
        for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
            new_referrers[i] = entry-&gt;inline_referrers[i];
        }
        entry-&gt;referrers = new_referrers;
        entry-&gt;num_refs = WEAK_INLINE_COUNT;
        entry-&gt;out_of_line = 1;
        entry-&gt;mask = WEAK_INLINE_COUNT-1;
        entry-&gt;max_hash_displacement = 0;
    }

    assert(entry-&gt;out_of_line);

    if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) {
        return grow_refs_and_insert(entry, new_referrer);
    }
    
    size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);
    size_t hash_displacement = 0;
    // 找到可以存放 new_referrer 的索引位置
    while (entry-&gt;referrers[index] != NULL) {
        index = (index+1) &amp; entry-&gt;mask;
        hash_displacement++;
    }
    if (hash_displacement &gt; entry-&gt;max_hash_displacement) {
        entry-&gt;max_hash_displacement = hash_displacement;
    }
    // 将 index 处的对象替换成 new_referrer
    weak_referrer_t &amp;ref = entry-&gt;referrers[index];
    ref = new_referrer;
    // 总数加一
    entry-&gt;num_refs++;
}
</code></pre>
<p><code>append_referrer</code> 是在三级 <code>hash</code> 表 <code>entry</code> 中出入一个新的弱引用着 <code>new_referrer</code>。</p>
<p>分为三种情况：</p>
<ol>
<li>如果 <code>inline_referrers</code> 没有存储满，直接存储到 <code>inline_referrers</code> 中。</li>
<li>如果 <code>inline_referrers</code> 个数是4个了，再插入，就需要将 <code>inline_referrers</code> 拷贝到 <code>referrers</code>，然后进入第三步。</li>
<li>如果 <code>referrers</code> 存储满了，判断是否需要扩容，然后将数据存储到 <code>referrers</code> 中。</li>
</ol>
<p>存储到 <code>inline_referrers</code> 的代码是：</p>
<pre><code class="language-cpp">for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
    if (entry-&gt;inline_referrers[i] == nil) {
        entry-&gt;inline_referrers[i] = new_referrer;
        return;
    }
}
</code></pre>
<p>存储完成后，直接返回了，所以后面的代码就是存储在 <code>referrers</code> 的情况。</p>
<pre><code class="language-cpp">weak_referrer_t *new_referrers = (weak_referrer_t *)
    calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));
    
    
// 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中
for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) {
    new_referrers[i] = entry-&gt;inline_referrers[i];
}
entry-&gt;referrers = new_referrers;
entry-&gt;num_refs = WEAK_INLINE_COUNT;
entry-&gt;out_of_line = 1;
entry-&gt;mask = WEAK_INLINE_COUNT-1;
entry-&gt;max_hash_displacement = 0;
</code></pre>
<p>这段代码的功能是 <code>inline_referrers</code> 正好4个，如果再次添加，肯定放不下了，所以将 <code>inline_referrers</code> 中的数据移到 <code>referrers</code> 中。</p>
<pre><code class="language-cpp">if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) {
    return grow_refs_and_insert(entry, new_referrer);
}
</code></pre>
<p>如果使用超过 <code>3/4</code>，就先扩容，然后再插入。</p>
<pre><code class="language-cpp">size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);
size_t hash_displacement = 0;
// 找到可以存放 new_referrer 的索引位置
while (entry-&gt;referrers[index] != NULL) {
    index = (index+1) &amp; entry-&gt;mask;
    hash_displacement++;
}
if (hash_displacement &gt; entry-&gt;max_hash_displacement) {
    entry-&gt;max_hash_displacement = hash_displacement;
}
// 将 index 处的对象替换成 new_referrer
weak_referrer_t &amp;ref = entry-&gt;referrers[index];
ref = new_referrer;
// 总数加一
entry-&gt;num_refs++;
</code></pre>
<p>上面的代码是通过弱引用着 <code>new_referrer</code> 找到 <code>index</code> 。然后从 <code>index</code> 开始，寻址空位置，将 <code>new_referrer</code> 插入到 <code>entry-&gt;referrers[index]</code> 位置处。同时将 <code>entry-&gt;num_refs</code> 累加。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p><code>weak</code> 即是一个三级 <code>hash</code> 表。</p>
<ol>
<li>第一级用来提高效率的，可以想象，很多对象，放到一个 <code>hash</code> 表中，降低了效率。所有将多有的对象散列到64个表中。</li>
<li>二级缓存存储被弱引用的对象。</li>
<li>三级缓存存储某个对象的所有的弱引用者。</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/08/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OC.html'>OC</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892554464.html">
                
                  <h1>CocoaPods组件化——OC/Swift动静态库混用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E7%BC%98%E8%B5%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缘起</h2>
<p>一个swift库，<code>charts</code>。</p>
<p>项目本身是通过 <code>cocoapods</code> 进行组件化管理的。</p>
<p>在没有集成 <code>charts</code> 之前，一切都是那么的美好，天是晴的，雨是停的。</p>
<p>直到有一天，因为业务需要图表功能，经一番调研之后，选择了 <code>charts</code> 集成到工程之中。</p>
<p>然后噩梦就开始了。</p>
<p>直接集成跑项目会直接报上百个错，因为 <code>charts</code> 是用swift写的，错误简要如下:</p>
<pre><code class="language-shell">Undefined symbols for architecture x86_64:
  &quot;protocol witness table for Swift.Double : Swift.CVarArg in Swift&quot;, referenced from:
      static Charts.XFChartString.format2f(number: Swift.Double) -&gt; Swift.String in libCharts.a(XFChartUtils.o)
  &quot;base conformance descriptor for Swift.Comparable: Swift.Equatable&quot;, referenced from:
      protocol conformance descriptor for Charts.(LineAlt in _35CAD2F96B83BFC8E7052E13186FFBAD) : Swift.Comparable in Charts in libCharts.a(DataApproximator+N.o)
  &quot;method descriptor for static Swift.Comparable.&lt; infix(A, A) -&gt; Swift.Bool&quot;, referenced from:
      protocol conformance descriptor for Charts.(LineAlt in _35CAD2F96B83BFC8E7052E13186FFBAD) : Swift.Comparable in Charts in libCharts.a(DataApproximator+N.o)
</code></pre>
<p>当时没想太多（这就是过于依赖搜索了，连分析都没直接去搜），搜的如何的oc项目通过 pod 集成swift代码。</p>
<p>大概翻了几篇的意思是swift只能动态库打包，需要 pod 管理的库改成动态库，其实这都是老黄历了，都是 pod1.5 之前的方案，不过我当时还是无脑跟着这么做了。</p>
<p>其实在这时候里胜利只差一步，结果绕了一个大弯子。如果不想看我废话这么多的，可以直接转到<strong>结局</strong>去看。</p>
<h2><a id="use-frameworks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>use_frameworks!</h2>
<p>在 <code>Podfile</code>中加入 <code>use_frameworks!</code>，就可以让 pod 管理的库都改成动态库。</p>
<p>加上之后，重新 <code>pod install</code> 一下。</p>
<p>然后项目一跑，果然不报错了，哎呦，牛逼，这就解决了。</p>
<p>心里美滋滋的，现在回头来看，还是太年轻了，直接把库都弄成动态库，后面还有成吨的依赖问题在等着我。。</p>
<p>就如下面的标题：<br />
动静态库 pod 内部依赖静态lib，静态framewor，动态framework，都是坑！</p>
<h2><a id="%E5%8A%A8%E6%80%81%E5%BA%93pod%E4%B8%AD%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81-lib" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态库 Pod 中嵌入静态 lib</h2>
<p>先说一下最先遇到的就是动态库 Pod 中嵌入静态lib。</p>
<p>vendored_library属性对应依赖的.a，然后依赖系统库在library，frameworks里加上。</p>
<p>最后就是.h,如果你不想暴露的话public_header_files里加完就不用管了，如果想要暴露给别人调用，只能source_files里再加一遍.h。</p>
<p>不想在source_files里再写一遍的也可以建个.h引用一遍所有.a的头文件，最后source_files写你自己的.h，但这只是保证我到处可以通过引用自己的头文件实现方法调用，并不能单个引用对应.a的头文件。</p>
<h2><a id="%E5%8A%A8%E6%80%81%E5%BA%93pod%E5%B5%8C%E5%85%A5%E9%9D%99%E6%80%81-framework" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态库 Pod 嵌入静态 Framework</h2>
<p>对静态的Framework封装的时候可以说是最简单的了，vendored_frameworks加上去基本就万事大吉了，至于依赖啥系统库什么的跟上面一样。</p>
<h2><a id="%E5%8A%A8%E6%80%81%E5%BA%93pod%E5%B5%8C%E5%85%A5%E5%8A%A8%E6%80%81-framework" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态库 Pod 嵌入动态 Framework</h2>
<p>对于动态的Framework封装，是最恶心的，就算不用 pod 也是很麻烦的。</p>
<p>不用 pod 你要手动把这SDK拖到Embedded Binaries位置头文件才能引用，这个是苹果现在引用动态Framework的方法。</p>
<p>下面讲一下 pod 怎么搞，如果单纯framework做 pod，首先public_header_files要指定xxx.framework/Headers/{.h}不然头文件找不到。</p>
<p>其次source_files里看具体编译情况决定加不加xxx.framework/Headers/{.h}，然后就是比较普通的地方vendored_frameworks指定好就完事了。</p>
<p>source_files这个加了的时候还有一个前提就是Framework内引用全是&quot;&quot;不能&lt;&gt;，所以大部分情况source_files不加。</p>
<p>另一种混合使用感觉这才是最常见的。</p>
<p>这时候不要指定Framework的public_header_files，写一个自己的头文件引用类，把想公开可以调用的写在在头文件引用类里如：<code>#import &lt;xxx.framework/xxx.h&gt;</code>，间接把xxx.h暴露出来。</p>
<h2><a id="%E9%9D%99%E6%80%81%E5%BA%93pod%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态库 Pod 资源文件的调用</h2>
<p>静态库其实还好，跟 pod 有关的resourced都在相应的 <code>pod库名.bundle</code> 之中。<br />
只需要用下面方法，就可以取出bundle，然海找相应的资源。</p>
<pre><code class="language-swift">+ (NSBundle *)staticLibBundleWithModuleName:(NSString *)moduleName {
    
    NSURL *bundleURL = [[NSBundle mainBundle] URLForResource:moduleName withExtension:@&quot;bundle&quot;];
    NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];
    return bundle;
}
</code></pre>
<h2><a id="%E5%8A%A8%E6%80%81%E5%BA%93pod%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态库 Pod 资源文件的调用</h2>
<p>每错，新坑出来了，动态 pod 中的静态framework，所依赖的资源图片找不到了。</p>
<p>打开ipa一看，路径全变了，pod 建动态库的时候的bundle都在相应的Framework里了。</p>
<p>大概路径就是：<code>xxx.ipa/Frameworks/xxxpod.framework/xxxpod.bundle</code></p>
<p>真坑。。</p>
<p>所以获取bundle的方法改成下面的了。</p>
<pre><code class="language-swift">+ (NSBundle *)dynamicLibBundleWithModuleName:(NSString *)moduleName {
    
    NSURL *bundleURL = [[NSBundle mainBundle] URLForResource:@&quot;Frameworks&quot; withExtension:nil];
    bundleURL = [bundleURL URLByAppendingPathComponent:moduleName];
    bundleURL = [bundleURL URLByAppendingPathExtension:@&quot;framework&quot;];
    bundleURL = [bundleURL URLByAppendingPathComponent:moduleName];
    bundleURL = [bundleURL URLByAppendingPathExtension:@&quot;bundle&quot;];
    
    NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];
    return bundle;
}
</code></pre>
<h2><a id="%E5%85%B3%E4%BA%8E%E5%8A%A8%E9%9D%99%E4%B9%8B%E4%BA%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于动静之争</h2>
<p>关于动态库和静态库的优劣网上一堆一堆的文章在说，这里就不废话了。</p>
<p>不过我个人倾向是用静态库的，事少，而且启动速度一些，说白了就是空间换时间。</p>
<p>安卓的art技术也是在空间换时间。</p>
<p>这年头空间哪有时间贵啊，手机容量再小，连这点都没有的那也不是我们的有效客户了。</p>
<h2><a id="%E7%BB%93%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结局</h2>
<p>故事的答案是，我一开始以为swift不能打成静态库，所以导致的报错，其实并不是的。</p>
<p>当时报这个错是 <code>Undefined symbols</code> 错误，在后来把报错一搜，找到了 <code>stackoverflow</code> 上一个<a href="https://stackoverflow.com/questions/52536380/why-linker-link-static-libraries-with-errors-ios">帖子</a>。</p>
<p>大概意思就是这个OC的项目不知道要编译Swift的代码才报错，只需要在主工程中，建一个空的swift文件并自动建一个bridge，然后就可以了。</p>
<p>没错，智慧就是这么简单，而我绕了好大的一个弯。</p>
<h2><a id="%E5%BD%A9%E8%9B%8B1%EF%BC%9Axcode9swift%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%94%AF%E6%8C%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>彩蛋1：Xcode9swift静态库的支持</h2>
<p>一开始查的结果其实就是过时的，早在Xcode9，swift就支持打成静态库了，所以不用非要弄成动态库。</p>
<h2><a id="%E5%BD%A9%E8%9B%8B2-pod1-5-use-modular-headers" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>彩蛋2: pod1.5 use_modular_headers!</h2>
<p>随着支持swift静态库，pod1.5也更新的对应的功能，如果swift的 pod 依赖于某个OC的 pod，需要为该OC版 pod 启用<code>modular headers</code>，所以多了 <code>use_modular_headers!</code>来全局开启，不过开启之后，之前一些不严谨的依赖，可能会报错，需要具体情况具体分析了，网上相关的文章也很多，就不在这里一一赘述了。而且我也不建议这种跨语言的交叉依赖，比如我的项目主要是OC，依赖的swift版 pod，就是纯swift写的。</p>
<h2><a id="%E5%86%8D%E6%9D%A5%E7%82%B9%E5%BA%9F%E8%AF%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>再来点废话</h2>
<p>虽然是过去式了，但是之前用 <code>use_frameworks!</code> 的时候，发现会给每一个 pod 创建一个 <code>umbrella.h</code> 文件，而这个文件里会有 pod 里所有的.h，当然这个是可以通过 podspec 中的属性控制的。如果 pod 里有 cpp 之类的文件，各种引用问题就很烦人了，还得一点一点改。</p>
<p>这是去年建新项目的时候一点心路历程，只是大概记个印象了，有的细节也不是很清楚了，等后面再遇到或者想起来了，再补充把。</p>
<h2><a id="%E5%BC%95%E7%94%A8%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引用：</h2>
<blockquote>
<p><a href="https://stackoverflow.com/questions/52536380why-linker-link-static-libraries-with-errors-ios">https://stackoverflow.com/questions/52536380why-linker-link-static-libraries-with-errors-ios</a><br />
<a href="https://cloud.tencent.com/developer/news/252403">https://cloud.tencent.com/developer/news/252403</a><br />
<a href="https://www.jianshu.com/p/10ed66dae403">https://www.jianshu.com/p/10ed66dae403</a><br />
<a href="https://blog.csdn.net/ios8988/article/details/84111011">https://blog.csdn.net/ios8988/article/details/84111011</a><br />
<a href="https://www.jianshu.com/p/544df88b6a1e">https://www.jianshu.com/p/544df88b6a1e</a><br />
<a href="https://www.jianshu.com/p/be9c848d050f">https://www.jianshu.com/p/be9c848d050f</a><br />
<a href="https://www.jianshu.com/p/4be1ef1dc3ff">https://www.jianshu.com/p/4be1ef1dc3ff</a><br />
<a href="https://www.jianshu.com/p/dfe9a1e1db7f">https://www.jianshu.com/p/dfe9a1e1db7f</a><br />
<a href="https://www.jianshu.com/p/913df8cc1f18">https://www.jianshu.com/p/913df8cc1f18</a><br />
<a href="https://www.jianshu.com/p/35db14a4931c">https://www.jianshu.com/p/35db14a4931c</a><br />
<a href="https://zhuanlan.zhihu.com/p/50571342">https://zhuanlan.zhihu.com/p/50571342</a></p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/08/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892557079.html">
                
                  <h1>当对象接收到不能处理的消息时调用的方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>当对象接收到不能处理的消息时调用的方法，下面三个方法会按顺序调用。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="17001892557079.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2020/03/03</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OC.html'>OC</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892554888.html">
                
                  <h1>iOS：如何在UITableView调用reloadData刷新结束后再同步执行后续操作</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>调用[tableView reloadData]时，系统并不会等待tableview更新结束后才执行后续代码，而是立即执行后续代码，然后异步地去计算scrollView的高度，获取cell等等。</p>
<p>但是我们又经常需要在tableview刷新结束后同步的执行某些操作，这个是一个隐藏的小坑，有时候稍不注意，就会写出来点Bug，这次有不小心遇到这个问题了，遂在此记录一下。</p>
<p>Apple并没有直接提供reloadData结束时的回调api，那么想要程序代码延迟到reloadData结束后再操作，可以通过以下两个方法来实现：</p>
<h2><a id="1%E9%80%9A%E8%BF%87-layoutifneeded%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BC%BA%E5%88%B6%E9%87%8D%E7%BB%98%E5%B9%B6%E7%AD%89%E5%BE%85%E5%AE%8C%E6%88%90%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 通过layoutIfNeeded方法，强制重绘并等待完成。</h2>
<pre><code class="language-swift">[self.tableView reloadData]; 

[self.tableView layoutIfNeeded];  // 刷新完成，执行后续需要执行的代码
</code></pre>
<h2><a id="2-reloaddata%E6%96%B9%E6%B3%95%E4%BC%9A%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%80%9A%E8%BF%87gcd%EF%BC%8C%E4%BD%BF%E5%90%8E%E7%BB%AD%E6%93%8D%E4%BD%9C%E6%8E%92%E9%98%9F%E5%9C%A8reloaddata%E5%90%8E%E9%9D%A2%E6%89%A7%E8%A1%8C%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.reloadData方法会在主线程执行，通过GCD，使后续操作排队在reloadData后面执行。</h2>
<pre><code class="language-swift">[self.tableView reloadData]; 

dispatch_async(dispatch_get_main_queue(), ^{ 
    //刷新完成，执行后续代码
});
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2020/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UI.html'>UI</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892554721.html">
                
                  <h1>统计iOS工程代码行数</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>虽然说这是一件毫无意义的事，而且如果代码打成库，统计还不准确。。当时有时候就是需要统计，比如说现在这个时间节点。。</p>
<pre><code class="language-plain_text"># 这个是包含空格的
find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -name &quot;*.xib&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.c&quot; -or -name &quot;*.rss&quot; &quot;)&quot; -print | xargs wc -l

# 不包含空格的
find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -name &quot;*.xib&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.c&quot; -or -name &quot;*.rss&quot; &quot;)&quot; -print  | xargs grep -v &quot;^$&quot; | wc -l
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/12/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892558986.html">
                
                  <h1>Objective-C Type Encodings</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>转自：<a href="https://nshipster.cn/type-encodings/">nshipster</a>，觉得再某些场景上有点用，就直接抄过来了。</p>
<p>@encode，@编译器指令 之一，返回一个给定类型编码为一种内部表示的字符串（例如，@encode(int) → i），类似于 ANSI C 的 typeof 操作。苹果的 Objective-C 运行时库内部利用类型编码帮助加快消息分发。</p>
<p>这里有一个所有不同的 Objective-C 类型编码的概要：</p>
<p>Objective-C Type Encodings</p>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c</code></td>
<td><code>A char</code></td>
</tr>
<tr>
<td><code>i</code></td>
<td><code>An int</code></td>
</tr>
<tr>
<td><code>s</code></td>
<td><code>A short</code></td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>A longl is treated as a 32-bit quantity on 64-bit programs.</code></td>
</tr>
<tr>
<td><code>q</code></td>
<td><code>A long long</code></td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>An unsigned char</code></td>
</tr>
<tr>
<td><code>I</code></td>
<td><code>An unsigned int</code></td>
</tr>
<tr>
<td><code>S</code></td>
<td><code>An unsigned short</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>An unsigned long</code></td>
</tr>
<tr>
<td><code>Q</code></td>
<td><code>An unsigned long long</code></td>
</tr>
<tr>
<td><code>f</code></td>
<td><code>A float</code></td>
</tr>
<tr>
<td><code>d</code></td>
<td><code>A double</code></td>
</tr>
<tr>
<td><code>B</code></td>
<td><code>A C++ bool or a C99 _Bool</code></td>
</tr>
<tr>
<td><code>v</code></td>
<td><code>A void</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>A character string (char *)</code></td>
</tr>
<tr>
<td><code>@</code></td>
<td><code>An object (whether statically typed or typed id)</code></td>
</tr>
<tr>
<td><code>#</code></td>
<td><code>A class object (Class)</code></td>
</tr>
<tr>
<td><code>:</code></td>
<td><code>A method selector (</code>SEL<code>)</code></td>
</tr>
<tr>
<td><code>[*array type*]</code></td>
<td><code>An array</code></td>
</tr>
<tr>
<td><code>{*name=type...*}</code></td>
<td><code>A structure</code></td>
</tr>
<tr>
<td><code>(*name*=*type...*)</code></td>
<td><code>A union</code></td>
</tr>
<tr>
<td><code>bnum</code></td>
<td><code>A bit field of *num* bits</code></td>
</tr>
<tr>
<td><code>^type</code></td>
<td><code>A pointer to type</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td><code>An unknown type (among other things, this code is used for function pointers)</code></td>
</tr>
</tbody>
</table>
<p>当然，用图表很不错，但是用代码实践更好：</p>
<pre><code class="language-swift">NSLog(@&quot;int        : %s&quot;, @encode(int));
NSLog(@&quot;float      : %s&quot;, @encode(float));
NSLog(@&quot;float *    : %s&quot;, @encode(float*));
NSLog(@&quot;char       : %s&quot;, @encode(char));
NSLog(@&quot;char *     : %s&quot;, @encode(char *));
NSLog(@&quot;BOOL       : %s&quot;, @encode(BOOL));
NSLog(@&quot;void       : %s&quot;, @encode(void));
NSLog(@&quot;void *     : %s&quot;, @encode(void *));

NSLog(@&quot;NSObject * : %s&quot;, @encode(NSObject *));
NSLog(@&quot;NSObject   : %s&quot;, @encode(NSObject));
NSLog(@&quot;[NSObject] : %s&quot;, @encode(typeof([NSObject class])));
NSLog(@&quot;NSError ** : %s&quot;, @encode(typeof(NSError **)));

int intArray[5] = {1, 2, 3, 4, 5};
NSLog(@&quot;int[]      : %s&quot;, @encode(typeof(intArray)));

float floatArray[3] = {0.1f, 0.2f, 0.3f};
NSLog(@&quot;float[]    : %s&quot;, @encode(typeof(floatArray)));

typedef struct _struct {
    short a;
    long long b;
    unsigned long long c;
} Struct;
NSLog(@&quot;struct     : %s&quot;, @encode(typeof(Struct)));
</code></pre>
<p>结果：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th><strong>编码</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>i</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>f</code></td>
</tr>
<tr>
<td><code>float *</code></td>
<td><code>^f</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>c</code></td>
</tr>
<tr>
<td><code>char *</code></td>
<td><code>*</code></td>
</tr>
<tr>
<td><code>BOOL</code></td>
<td><code>c</code></td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>v</code></td>
</tr>
<tr>
<td><code>void *</code></td>
<td><code>^v</code></td>
</tr>
<tr>
<td><code>NSObject *</code></td>
<td><code>@</code></td>
</tr>
<tr>
<td><code>NSObject</code></td>
<td><code>#</code></td>
</tr>
<tr>
<td><code>[NSObject]</code></td>
<td><code>{NSObject=#}</code></td>
</tr>
<tr>
<td><code>NSError **</code></td>
<td><code>^@</code></td>
</tr>
<tr>
<td><code>int[]</code></td>
<td><code>[5i]</code></td>
</tr>
<tr>
<td><code>float[]</code></td>
<td><code>[3f]</code></td>
</tr>
<tr>
<td><code>struct</code></td>
<td><code>{_struct=sqQ}</code></td>
</tr>
</tbody>
</table>
<p>这里有一些特别需要注意的：</p>
<ul>
<li>指针的标准编码是加一个前置的 <code>^</code>，而 <code>char *</code> 拥有自己的编码 <code>*</code>。这在概念上是很好理解的，因为 C 的字符串被认为是一个实体，而不是指针。</li>
<li><code>BOOL</code> 是 <code>c</code>，而不是某些人以为的 <code>i</code>。原因是 <code>char</code> 比 <code>int</code> 小，且在 80 年代 Objective-C 最开始设计的时候，每一个 bit 位都比今天的要值钱（就像美元一样）。<code>BOOL</code> 更确切地说是 <code>signed char</code> （即使设置了 <code>-funsigned-char</code> 参数），以在不同编译器之间保持一致，因为 <code>char</code> 可以是 <code>signed</code> 或者 <code>unsigned</code>。</li>
<li>直接传入 <code>NSObject</code> 将产生 <code>#</code>。但是传入 <code>[NSObject class]</code> 产生一个名为 <code>NSObject</code>只有一个类字段的结构体。很明显，那就是 <code>isa</code> 字段，所有的 <code>NSObject</code> 实例都用它来表示自己的类型。</li>
</ul>
<h2><a id="%E6%96%B9%E6%B3%95%E7%BC%96%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法编码</h2>
<p>如苹果的 <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">“Objective-C Runtime Programming Guide”</a> 中所提到的，有一大把内部使用的类型编码无法用 <code>@encode()</code> 返回。</p>
<p>以下是协议中声明的方法的类型修饰符：</p>
<p>Objective-C Method Encodings</p>
<table>
<thead>
<tr>
<th><strong>编码</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>r</code></td>
<td><code>const</code></td>
</tr>
<tr>
<td><code>n</code></td>
<td><code>in</code></td>
</tr>
<tr>
<td><code>N</code></td>
<td><code>inout</code></td>
</tr>
<tr>
<td><code>o</code></td>
<td><code>out</code></td>
</tr>
<tr>
<td><code>O</code></td>
<td><code>bycopy</code></td>
</tr>
<tr>
<td><code>R</code></td>
<td><code>byref</code></td>
</tr>
<tr>
<td><code>V</code></td>
<td><code>oneway</code></td>
</tr>
</tbody>
</table>
<p>对于那些熟悉 <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSDistantObject_Class/Reference/Reference.html">NSDistantObject</a> 的人，你无疑会认出这些是 <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/DistrObjects/DistrObjects.html#//apple_ref/doc/uid/10000102i">Distributed Objects</a> 的残留。</p>
<p>尽管 DO (Distributed Objects) 在 iOS 时代已经不那么时髦了，它仍是用于 Cocoa 应用程序进程间通信的协议————甚至用于网络上的不同机器之间。在这些约束下，上下文里附加的内容就带来了很多好处。</p>
<p>例如，分页式的对象消息的参数默认是用代理传递的。在那些没必要用到低效的代理的情况下，增加一个 <code>bycopy</code> 修饰符以保证发送了一份完整的拷贝。同样，默认情况下，带用 <code>inout</code> 的参数表明它在发消息时对象即可传入又可传出。将参数特别标注为 <code>in</code> 或 <code>out</code>，程序将避免一些来回的开销。</p>
<hr />
<p>我们从对 Objective-C 的类型编码的全新理解上能得到什么呢？ 不瞒您说，其实没多少（除非你在做一些疯狂的元编程）。</p>
<p>但是就如我们最开始所说的，在追求破译密文的过程中要用到不少智慧。</p>
<p>看看类型编码为我们展现的有关 Objective-C 内部的细节，这本身就是一种高尚的追求。如果刨根问到底的话，我们需要了解一下 Distributed Objects 神秘的历史以及那 <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSNumberFormatter_Class/Reference/Reference.html%23jumpTo_22">至今仍然存在</a> 的复杂的参数修饰符。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/04/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OC.html'>OC</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892556042.html">
                
                  <h1>Objective-C：为什么分类中不能直接添加属性</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>为什么分类中不能直接添加属性，这个也是一个经典的面试题了。</p>
<p>搜了一些相关文章，再结合源码做了一个小小的总结。</p>
<p>其实通过这个问题，也可以一瞥 OC 中类的实现。</p>
<h2><a id="%E6%BA%90%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码</h2>
<p>先晒一下OC类和分类的部分源码：</p>
<pre><code class="language-swift">typedef struct objc_class *Class;

struct objc_class : objc_object {
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags

    ...
}


struct class_data_bits_t {
    ...

    class_rw_t* data() {
        return (class_rw_t *)(bits &amp; FAST_DATA_MASK);
    }

    ...
}

struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;
    
    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;

    ...
}

struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;
    
    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
</code></pre>
<p>从上面可以看出来Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。<br />
ivars是objc_ivar_list（成员变量列表）指针，其在objc_class中关系如下。</p>
<pre><code class="language-swift">objc_class -&gt; class_data_bits_t bits -&gt; class_rw_t* data() -&gt; const class_ro_t *ro -&gt; const ivar_list_t * ivars;
</code></pre>
<p>再看一下Category的定义。</p>
<pre><code class="language-swift">typedef struct category_t *Category;

struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    struct property_list_t *_classProperties;

    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }

    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
</code></pre>
<p>从Category的定义也可以看出Category有实例方法，类方法，甚至可以实现协议，添加属性，但是没有实例变量。</p>
<h2><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h2>
<p>参考了位博主文章之后，这里再补充一下。</p>
<p>博主文章链接：<a href="http://www.jianshu.com/p/935142af6a47">http://www.jianshu.com/p/935142af6a47</a></p>
<p>通过上面的文章里面的详细介绍以及打印输出，可以看到，在一个分类中添加了一个属性，Xcode不会自动的为其生成一个下划线开头的成员变量及set和get方法。</p>
<p>如果你没有手动的实现这两个方法，直接在外面通过点语法调用这个属性，肯定就直接挂了，Unrecognised selector send to instance。</p>
<p>因为他就没有这两个方法，能不挂吗？所以当你真的在分类中声明了一个属性的时候，就要手动的去实现这个属性的set和get方法，这个时候就要用到运行时机制了，关联上去这个属性的存取过程。</p>
<h2><a id="%E7%BB%93%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结论</h2>
<p>为什么不能为手动添加一个下划线开头的成员变量，然后在实现存取器方法的时候对这个成员变量来存取呢？非要用到所谓的运行时吗？</p>
<p>答案是因为：成员变量是一个类的东西，分类本身就不是一个类，它并没有自己的bits，以及后面的一些东西，分类本来就是OC里面通过运行时动态的为一个类添加的一些方法和属性等，不是一个真正的类，你怎么给他添加成员变量呢。</p>
<p>而因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。</p>
<p>总结一下，其实分类中是可以为一个类添加属性的，但是一定做不到添加成员变量，不要混淆了成员变量和属性的概念。</p>
<p>只是说现在Xcode自动会给属性生成成员变量让大家对这个概念有点混淆。Property是Property，Ivar是Ivar。</p>
<p>有兴趣可以研究一下类是怎么被创建出来的，类最开始生成了很多基本属性，比如IvarList，MethodList，分类只会将自己的method attach到主类，并不会影响到主类的IvarList。</p>
<p>这就是为什么分类里面不能增加成员变量的原因。</p>
<h2><a id="%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考</h2>
<blockquote>
<p><a href="https://blog.csdn.net/JGL357/article/details/79127483">https://blog.csdn.net/JGL357/article/details/79127483</a><br />
<a href="https://www.jianshu.com/p/8aa63f7e98d1">https://www.jianshu.com/p/8aa63f7e98d1</a><br />
<a href="https://blog.csdn.net/mumuyinyin/article/details/72854579">https://blog.csdn.net/mumuyinyin/article/details/72854579</a><br />
<a href="https://tech.meituan.com/DiveIntoCategory.html">https://tech.meituan.com/DiveIntoCategory.html</a></p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/03/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='OC.html'>OC</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="17001892554959.html">
                
                  <h1>Fishhook-源码分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h1><a id="fishhook%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fishhook-源码分析</h1>
<p>看腾讯开源的iOS内存监控组件<a href="https://github.com/Tencent/OOMDetector">OOMDetector</a>的过程中，发现其内部使用了Facebook开源的<a href="https://github.com/facebook/fishhook">fishhook</a>。遂跟着研究了一下这个库。</p>
<p>fishhook可以在模拟器和设备上的iOS上运行的Mach-O二进制文件中动态重新绑定符号，可以交换C的函数。</p>
<p>fishhook代码量不多，一共就两个文件fishhook.h和fishhook.c。其中.c文件只有200多行，整体所以看起来不是很复杂的，不过其中涉及到了 <code>Mach-O</code> 和函数指针相关的知识，想看懂这些代码还是需要一些基础的。</p>
<p>先看一下调用流程。</p>
<h2><a id="%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用流程</h2>
<pre><code class="language-c">int rebind_symbols_image(void *header,
                         intptr_t slide,
                         struct rebinding rebindings[],
                         size_t rebindings_nel);

int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);
</code></pre>
<p>这两个函数是暴漏在.h，给用户调用的，其内部都是直接或者间接调用了</p>
<pre><code class="language-c">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,
                                     const struct mach_header *header,
                                     intptr_t slide);
</code></pre>
<p>接着最终调用</p>
<pre><code class="language-c">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,
                                           section_t *section,
                                           intptr_t slide,
                                           nlist_t *symtab,
                                           char *strtab,
                                           uint32_t *indirect_symtab);
</code></pre>
<p>大概流程就是这样了，其中在<code>perform_rebinding_with_section</code>函数中这段代码是交换函数的地方</p>
<pre><code class="language-c">if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;
    indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) {
    *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];
}
indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;
</code></pre>
<h2><a id="%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8%EF%BC%88oomdetector%E4%B8%AD%E6%9B%BF%E6%8D%A2malloc%E7%AD%89%E5%87%BD%E6%95%B0%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实例应用（OOMDetector中替换malloc等函数）</h2>
<p>此实例是OOMDetector使用fishhook替换malloc函数。</p>
<p>下面的替换malloc等函数的入口函数<code>hookMalloc</code>，该函数调用了OOMDetector的<code>rebind_symbols_for_imagename</code>函数。</p>
<pre><code class="language-c">void hookMalloc()
{
    if(!isPaused){
        beSureAllRebindingFuncBeenCalled();
        
        orig_malloc = malloc;
        orig_calloc = calloc;
        orig_valloc = valloc;
        orig_realloc = realloc;
        orig_block_copy = _Block_copy;
        rebind_symbols_for_imagename(
                                     (struct rebinding[5]){
                                                        {&quot;realloc&quot;,(void*)new_realloc,(void**)&amp;orig_realloc},
                                                        {&quot;malloc&quot;, (void*)new_malloc, (void **)&amp;orig_malloc},
                                                        {&quot;valloc&quot;,(void*)new_valloc,(void**)&amp;orig_valloc},
                                                        {&quot;calloc&quot;,(void*)new_calloc,(void**)&amp;orig_calloc},
                                                        {&quot;_Block_copy&quot;,(void*)new_block_copy,(void**)&amp;orig_block_copy}},
                                     5,
                                     getImagename());
    }
    else{
        isPaused = false;
    }

}
</code></pre>
<p><code>hookMalloc</code>替换了<code>realloc</code>、<code>malloc</code>、<code>valloc</code>、<code>calloc</code>、<code>_Block_copy</code>这几个函数。</p>
<p>下面是新的<code>new_malloc</code>函数定义：</p>
<pre><code class="language-c">static void* (*orig_malloc)(size_t);
static void* (*orig_calloc)(size_t, size_t);
static void* (*orig_realloc)(void *, size_t);
static void* (*orig_valloc)(size_t);
static void* (*orig_block_copy)(const void *aBlock);
</code></pre>
<p>下面是<code>rebind_symbols_for_imagename</code>第三个入参————镜像名称的获取方式：</p>
<pre><code class="language-c">const char *getImagename()
{
    const char* name = _dyld_get_image_name(0);
    const char* tmp = strrchr(name, '/');
    if (tmp) {
        name = tmp + 1;
    }
    return name;
}
</code></pre>
<p>调用了<code>&lt;mach-o/dyld.h&gt;</code> 头文件中的<code>_dyld_get_image_name</code>函数。 <code>_dyld_get_image_name</code> 根据镜像的索引，获取镜像的名称。<code>strrchr</code>函数是反向查找第一个给定字符。返回第一次匹配到的地址指针。</p>
<p><code>rebind_symbols_for_imagename</code>函数是调用了fishhook中的<code>rebind_symbols_image</code>函数实现了函数的交换。</p>
<pre><code class="language-c">void rebind_symbols_for_imagename(struct rebinding rebindings[],
                                  size_t rebindings_nel,
                                  const char *imagename)
{
    uint32_t count = _dyld_image_count();
    for (uint32_t i = 0; i &lt; count; i++) {
        const mach_header_t* header = (const mach_header_t*)_dyld_get_image_header(i);
        const char* name = _dyld_get_image_name(i);
        const char* tmp = strrchr(name, '/');
        long slide = _dyld_get_image_vmaddr_slide(i);
        if (tmp) {
            name = tmp + 1;
        }
        if(strcmp(name,imagename) == 0){
            rebind_symbols_image((void *)header,
                                 slide,
                                 rebindings,
                                 rebindings_nel);
            break;
        }
    }
}

</code></pre>
<p><code>rebindings</code>承载重新绑定的所有信息，<code>rebindings_nel</code>是<code>rebindings</code>的个数，<code>imagename</code>要替换函数指针镜像名称，也就是只替换名称为<code>imagename</code>文件中的函数指针，其他库不做替换。</p>
<p><code>_dyld_get_image_header</code> 获取镜像的header头，<code>_dyld_get_image_vmaddr_slide</code>获取镜像的随机启动地址。<code>rebind_symbols_image</code>函数为重新绑定做准备，增加了两个参数，header、slide。header就是加载到内存的中二进制文件的头。slide 的是ALSR技术中的随机启动地址。这个地址的含义可以参考<a href="https://stackoverflow.com/questions/13574933/ios-crash-reports-atos-not-working-as-expected/13576028#13576028">iOS crash reports: atos not working as expected</a>、 <a href="https://www.cnblogs.com/feng9exe/p/7988360.html">iOS crash log 解析 symbol address = stack address - slide 运行时获取slide的api 利用dwarfdump从dsym文件中得到symbol</a> 。</p>
<h3><a id="%E5%85%B3%E4%BA%8Ealsr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于ALSR</h3>
<p>下面为了理解ALSR中的slide，贴出一段测试代码：</p>
<pre><code class="language-c">void understandALSR()
{
    ///枚举所有镜像
    for (int i = 0; i &lt; _dyld_image_count(); i++)
    {
        char *image_name = (char *)_dyld_get_image_name(i);
        const struct mach_header *mh = _dyld_get_image_header(i);
        intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i);
        
        printf(&quot;Image name %s ,image header 0x%llx , ASLR slide 0x%lx.\n&quot;,
               image_name, (mach_vm_address_t)mh, vmaddr_slide);
    }
}
</code></pre>
<p>输出如下：</p>
<pre><code class="language-plain_text">Image name /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/dyld_sim ,image header 0x107ca6000 , ASLR slide 0x107ca6000.

Image name /Users/ankang/Library/Developer/CoreSimulator/Devices/C9991234-7FA4-4F9E-9C73-629AFC886DC1/data/Containers/Bundle/Application/5C4118B1-2236-4A9C-B0A3-0DF77D765054/LearnMachO.app/LearnMachO ,image header 0x107c9c000 , ASLR slide 0x7c9c000.
</code></pre>
<p>代码对应的二进制文件中的加载地址（链接时load address）示意图：</p>
<p><img src="media/17001892554959/17001910799965.jpg" alt="macho01" /></p>
<p><img src="media/17001892554959/17001910799978.jpg" alt="macho02" /></p>
<p>结合上面的示例代码和二进制内容图片，可以诠释下面的公式：</p>
<pre><code class="language-c">slide = (运行时)load address - (链接时)load address;
symble address ＝ stack address - slide；
</code></pre>
<p>其中：</p>
<ol>
<li>stack address ： 程序运行时线程栈中所有函数调用的地址。</li>
<li>symble address ： dsym文件中函数符号对应的地址，用此地址在dsym文件中可以查出对应的符号信息。</li>
</ol>
<p>可以看出，没有ASLR时：</p>
<pre><code class="language-plain_text">symble address =  stack address
</code></pre>
<h2><a id="%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>源码分析</h2>
<p>fishhook代码这么少，所以可以进行一次全面的分析了。</p>
<p>首先，fishhook定义了一个结构体，存储绑定的数据。定义如下：</p>
<pre><code class="language-c">/*
 * A structure representing a particular intended rebinding from a symbol
 * name to its replacement
 */
struct rebinding {
  const char *name;  `  //替换的函数名字
  void *replacement;	//替换后的函数指针
  void **replaced;      //原始的方法
};
</code></pre>
<p>接着看<code>rebind_symbols_image</code>函数：</p>
<pre><code class="language-c">int rebind_symbols_image(void *header,
                         intptr_t slide,
                         struct rebinding rebindings[],
                         size_t rebindings_nel) {
    struct rebindings_entry *rebindings_head = NULL;
    int retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);
    rebind_symbols_for_image(rebindings_head, (const struct mach_header *) header, slide);
    if (rebindings_head) {
      free(rebindings_head-&gt;rebindings);
    }
    free(rebindings_head);
    return retval;
}
</code></pre>
<p><code>rebind_symbols_image</code> 主要工作是通过<code>prepend_rebindings</code>构造绑定的结构体<code>struct rebindings_entry</code>，定义如下：</p>
<pre><code class="language-c">struct rebindings_entry {
  struct rebinding *rebindings;
  size_t rebindings_nel;
  struct rebindings_entry *next;
};

static int prepend_rebindings(struct rebindings_entry **rebindings_head,
                              struct rebinding rebindings[],
                              size_t nel) {
  // 申请new_entry地址  
  struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry));
  if (!new_entry) {
    return -1;
  }
  // 给new_entry-&gt;rebindings分配内存
  new_entry-&gt;rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel);
  if (!new_entry-&gt;rebindings) {
    free(new_entry);
    return -1;
  }
  // 拷贝重新绑定信息到new_entry-&gt;rebindings  
  memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel);
  new_entry-&gt;rebindings_nel = nel;
  new_entry-&gt;next = *rebindings_head;
    
  // 这个将创建的new_entry赋值给rebindings_head，通过二级指针返回给调用者
  *rebindings_head = new_entry;
  return 0;
}
</code></pre>
<p><code>prepend_rebindings</code>只是将绑定的<code>struct rebinding</code>类型参数转化为<code>struct rebindings_entry</code>结构，这种结构类似链表，可以方便的管理多个<code>struct rebinding</code>结构。下面看<code>rebind_symbols_for_image</code>：</p>
<pre><code class="language-c">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,
                                     const struct mach_header *header,
                                     intptr_t slide) {
  Dl_info info;
  // find the image containing a given address
  // 验证库是否存在
  if (dladdr(header, &amp;info) == 0) {
    return;
  }

  segment_command_t *cur_seg_cmd;
  
  // SEG_LINKEDIT commond指针
  segment_command_t *linkedit_segment = NULL;
  // LC_SYMTAB commond指针
  struct symtab_command* symtab_cmd = NULL;
  // LC_DYSYMTAB commond指针
  struct dysymtab_command* dysymtab_cmd = NULL;
	
  // 定位linkedit_segment、symtab_cmd、dysymtab_cmd三指针
  uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);
  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize)
  {
    cur_seg_cmd = (segment_command_t *)cur;
    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)
    {
      if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0)
      {
        linkedit_segment = cur_seg_cmd;
      }
    }
    else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB)
    {
      symtab_cmd = (struct symtab_command*)cur_seg_cmd;
    }
    else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB)
    {
      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;
    }
  }

  if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||
      !dysymtab_cmd-&gt;nindirectsyms) {
    return;
  }

  // Find base symbol/string table addresses 查找符号表和string表
  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;
  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);
  char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);

  // Get indirect symbol table (array of uint32_t indices into symbol table)
  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);

  cur = (uintptr_t)header + sizeof(mach_header_t);
  
  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) 
  {
    cur_seg_cmd = (segment_command_t *)cur;
    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)
    {
      if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp;
          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) {
        continue;
      }
      // 找到类型为S_LAZY_SYMBOL_POINTERS、S_NON_LAZY_SYMBOL_POINTERS类型的section
      for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) {
        section_t *sect =
          (section_t *)(cur + sizeof(segment_command_t)) + j;
        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) {
          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);
        }
        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) {
          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);
        }
      }
    }
  }
}
</code></pre>
<p><code>rebind_symbols_for_image</code> 函数主要定位到三表，类型为<code>S_LAZY_SYMBOL_POINTERS</code>、<code>S_NON_LAZY_SYMBOL_POINTERS</code>类型的section。然后调用<code>perform_rebinding_with_section</code> 函数。其中部分宏定义如下。</p>
<pre><code class="language-c">#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64
#define	SEG_LINKEDIT	&quot;__LINKEDIT&quot;
#define	S_NON_LAZY_SYMBOL_POINTERS 0x6  /* section with only non-lazy symbol pointers */
#define	S_LAZY_SYMBOL_POINTERS 0x7     /* section with only lazy symbol
</code></pre>
<p>上面的宏定义于<code>&lt;mach-o/loader.h&gt;</code>文件中，位于477行。 在<code>S_NON_LAZY_SYMBOL_POINTERS</code>宏的上面有一段注释。这段注释非常的关键。说明了<code>S_NON_LAZY_SYMBOL_POINTERS</code>类型的section中的数据和动态符号表中的符号是顺序对应的。只有理解了这段内容。才能真正的理解fishhook。</p>
<p>For the two types of symbol pointers sections and the symbol stubs section they have indirect symbol table entries.</p>
<p>对于存储符号指针、符号存根两种类型的section，它们有间接符号表条目。</p>
<p>For each of the entries in the section,the indirect symbol table entries, in corresponding order in the indirect symbol table, start at the index stored in the reserved1 field of the section structure.</p>
<p>间接符号表条目顺序对应section中的条目，对应从section的reserved1索引开始。</p>
<p>Since the indirect symbol table entries correspond to the entries in the section the number of indirect symbol table entries is inferred from the size of the section divided by the size of the entries in the section. For symbol pointers sections the size of the entries in the section is 4 bytes (看结构是8bytes，可能是64位的缘故)</p>
<p>由于间接符号表条目对应于section中的条目，因此间接符号表条目的数量由section的大小除以section中的条目的大小来推断。对于符号指针节，section中的条目的大小是4个字节</p>
<p>下面是<code>perform_rebinding_with_section</code>函数源码：</p>
<pre><code class="language-c">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,
                                           section_t *section,  // section
                                           intptr_t slide,     // 基址
                                           nlist_t *symtab,  // 符号表
                                           char *strtab,  // sting 表
                                           uint32_t *indirect_symtab // 动态符号表
                                           )
{
    // 动态符号表 对应section的地址，动态符号表的基地址+section对应的偏移量
    uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;

    // section加载到内存的虚拟地址（是要替换这里面的东西）
    void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr);
    
    // section中替换函数指针
    for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++)
    {
        // 由于section中条目和动态符号表中的条目对应，所以将section中的条目索引i用于动态符号表。
        // 下面目的是获取section中存储的函数指针的符号  动态符号表-&gt; 符号表-&gt; string表
        
        // indirect_symbol_indices[i]中存储符号表的索引。symtab_index就是符号表的索引
        uint32_t symtab_index = indirect_symbol_indices[i];
        if (symtab_index == INDIRECT_SYMBOL_ABS || 
            symtab_index == INDIRECT_SYMBOL_LOCAL ||
            symtab_index == (INDIRECT_SYMBOL_LOCAL | 
                             INDIRECT_SYMBOL_ABS))
        {
            continue;
        }
        // 通过nlist_t的n_strx找到String表的偏移地址，strtab_offset。
        uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;
        char *symbol_name = strtab + strtab_offset;
        if (strnlen(symbol_name, 2) &lt; 2)
        {
            continue;
        }
        
        ///依次枚举struct rebindings_entry 结构，判断时候有和当前函数指针相等的带替换的函数。
        struct rebindings_entry *cur = rebindings;
        while (cur)
        {
            for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++)
            {
                ///如果符号名称和替换的名称一样，进行替换
                if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0)
                {
                    if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;
                      indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement)
                    {
                        ///保存原始的指针地址，只保存一次
                        *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];
                    }
                    ///在section中替换。将indirect_symbol_bindings[i]中存储的函数指针地址进行替换。   
                    indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;
                    goto symbol_loop;
                }
            }
            cur = cur-&gt;next;
        }
        symbol_loop:;
    }
}
</code></pre>
<p><code>perform_rebinding_with_section</code>函数完成替换的关键函数。 将section中的函数指针替换为新的函数指针。</p>
<h2><a id="%E5%9B%BE%E8%A7%A3fishhook" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>图解fishhook</h2>
<p>同事画的9张图片解释fishhook原理，看代码懵逼的可以看看图，有助于理解</p>
<p><img src="media/17001892554959/17001910799995.jpg" alt="" /></p>
<p>图1. load command中_DATA segement中<code>__la_symbol_ptr</code> section结构图,说明该section和动态符号表对应的起始索引是146</p>
<p><img src="media/17001892554959/17001910800014.jpg" alt="" /></p>
<p>图2.数据区域中<code>__la_symbol_ptr</code>的结构,可以看出该section的起始地址是0x00240B0，图2和图3是为了找malloc函数指针的位置</p>
<p><img src="media/17001892554959/17001910800040.jpg" alt="" /></p>
<p>图3.数据区域中__la_symbol_ptr的结构, 偏移了一定的位置。文件0x000242B0地址出存储的是malloc函数指针。</p>
<p>计算偏移数量的方法：0x242B0 - 0x240B0 = 0x200<br />
每个条目占用8个字节0x200/0x8 = 0x40 = 64<br />
得出：在符号表中，malloc偏移64个条目</p>
<p><img src="media/17001892554959/17001910800072.jpg" alt="" /></p>
<p>图4 .转到数据区域中动态符号表的起始位置处，该图说明动态符号表的起始地址是0x3B0A4</p>
<p><img src="media/17001892554959/17001910800110.jpg" alt="" /></p>
<p>图5 。 计算<strong>la_symbol_ptr 对应的符号在动态符号表中的位置： 0x3B060 + 146*4 = 0x3B060 + 0x248 = 0x3B2A8，地址0x0003B2A8处后面的符号和</strong>la_symbol_ptr中的条目对应。</p>
<p><img src="media/17001892554959/17001910800152.jpg" alt="" /></p>
<p>图6 . 查找64个偏移后的动态符号表的地址：0x3B2A8 + 0x40*x4 = 0x3B3A8，地址0x3B3A8中存储的值是符号表中的索引，<br />
为0xb32。由于machoviewer看不到符号表，所以用代码查看符号表中索引为0xB32 的符号信息。</p>
<p>查看代码：<code>struct nlist_64 const * mallocNlist =[self getSymbol64ByIndex:0xB32];</code></p>
<p><img src="media/17001892554959/17001910800200.jpg" alt="" /></p>
<p>图7 .代码查看符号表示意图。符号表的索引为0xB32的符号的信息。可以看出n_strx的值是0x2B07，<br />
这个值指的是string表中的偏移量</p>
<p><img src="media/17001892554959/17001910800256.jpg" alt="" /></p>
<p>图8 .string 表，string表的起始地址是0x3B498</p>
<p><img src="media/17001892554959/17001910800333.jpg" alt="" /></p>
<p>图9 .string 表， 偏移0x2B07 后的结果—— 0x3B498 + 0x2B07 = 0x3DF9F， 这个地址存储的字符串就是图3中</p>
<p>地址为0x10001ef10的函数指针的名称，名称是malloc。这个名称和我么要替换的名称一致，所以替换图3中的<br />
0x10001ef10，替换成新指定函数指针地址。实现替换。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/01/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='iOS.html'>iOS</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="iOS_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>DreamEverAfter</h1>
                <div class="site-des"></div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="CS.html"><strong>CS</strong></a>
        
            <a href="List.html"><strong>List</strong></a>
        
            <a href="%E6%9D%82.html"><strong>杂</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16996865532784.html">三汁焖锅</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001172774052.html">别了，中国大陆的Kindle</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001265068678.html">HomeBrew更新报错“fatal- Could not resolve HEAD to a revision”</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001892553950.html">SwiftUI基本控件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="17001171363865.html">LiSSA第四代计时器说明书</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
